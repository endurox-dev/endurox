# List of caches to process by daemon (i.e. timeout)
#[@tpcached]
#caches=db1,cachesomesvc
# not need for this -> will process by CCTAG
#

# Simple cache
[@cachedb/db1]
cachedb=db1
resource=${TESTDIR}/db1
flags=bootreset

# Time limited cache
[@cachedb/db2]
cachedb=db2
resource=${TESTDIR}/db1
# Hmm maybe reset by cached not by ndrxd?
flags=bootreset

# Limited slots cache
#[@cachedb/cachesomesvc]
#dbpath=/path/to/some/limdb
# Optional:
#limit=1000
# Listen on events... (by cache mgmnt server)
#subscr_put=(@TPCPUT001|@TPCPUT02.)
#subscr_del=@TPCDEL...

# Reset cache file at boot.
# lru, hits, fifo -> requires limit. lru,hits,fifo  are exclusive, 
# only one should be present
#flags=bootreset,lru,hits,fifo,expiry,broadcast


#
# We shall support caches by process sub-sections. so that there could be 
# different caches used by different cctags
#
[@cache]
svc TESTSV=
    {
        "caches":[
#
# Standard cache
#
                {
                    "cachedb":"db1",
                    "type":"UBF",
                    "keyfmt":"SV1$(T_STRING_3_FLD)-$(T_STRING_2_FLD[1])",
                    "save":"*",
                    "rule":"T_LONG_FLD==4 && T_SHORT_FLD==3",
                    "rsprule":"EX_TPERRNO==0 && EX_TPURCODE==0"
# So if this true then we perform refresh either `rule' or `refreshrule'
                    "refreshrule":"T_LONG_FLD==100"
                }
                ,
                {
#
# Save list of fields
#
                    "cachedb":"db1",
                    "type":"UBF",
                    "keyfmt":"SV1$(T_STRING_3_FLD)-$(T_STRING_2_FLD[1])",
# Save by regex
                    "save":"^T_STRING_.*_FLD$",
                    "rule":"T_STRING_3_FLD=='CACHE2'",
                    "flags":"putrex,getmerge"
                },
#
# Save list of fields
#
                {
                    "cachedb":"cachesomesvc",
                    "type":"UBF",
                    "keyfmt":"$(T_STRING_5_FLD)-$(T_STRING_6_FLD)",
                    "save":"T_STRING_4_FLD,T_STRING_5_FLD",
                    "rule":"T_STRING_3_FLD=='CACHE3'",
                }
            ]   
    }

# Test some other service 
svc TESTSV2=
    {
        "caches":[
                {
                    "cachedb":"db1",
                    "type":"UBF",
                    "keyfmt":"SV2$(T_STRING_3_FLD)-$(T_STRING_2_FLD[1])",
                    "save":"*",
                    "rule":"T_LONG_FLD==4 && T_SHORT_FLD==3",
                    "rsprule":"EX_TPERRNO==0 && EX_TPURCODE==0"
                    "flags":"putfull,getreplace"
                },
                {
# this is irrevelant
                    "cachedb":"db1",
# types of tareget service shall match
                    "type":"UBF",
                    "invalsvc":"TESTSV"
# dest data key format to lookup & delete the record
                    "keyfmt":"SV2$(T_STRING_3_FLD)-$(T_STRING_2_FLD[1])",
# Not needed
                    "save":"*",
# rule to match shall we process this entry or not?
                    "rule":"T_LONG_FLD==4 && T_SHORT_FLD==3",
                    "flags":"inval"
                }
            ]
    }

[@debug]
*=ndrx=5 ubf=1 lines=1 bufsz=1000 file=${TESTDIR}/ndrx-dom1.log
xadmin=file=${TESTDIR}/xadmin-dom1.log
ndrxd=file=${TESTDIR}/ndrxd-dom1.log
atmiclt48=ndrx=1 file=${TESTDIR}/atmiclt-dom1.log
atmi.sv48=file=${TESTDIR}/atmisv-dom2.log
tpbridge=file=${TESTDIR}/tpbridge-dom1.log threaded=y


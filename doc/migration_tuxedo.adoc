Migrating from Oracle Tuxedo to Enduro/X
========================================
:doctype: book

== About the guide

This document describes different aspects which needs to be accounted for
when performing migration from Oracle Tuxedo to Enduro/X middleware.
The document describes common elements which Enduro/X covers from Tuxedo
functionality, how functionality and configuration differs.

Lastly document describes standard approach for performing configuration
migration for Tuxedo UBB Config to Enduro/X based configuration

Document shall be read by anybody which is involved into migration project
from Oracle Tuxedo to Enduro/X middleware.

== Overview

Both systems are build on X/Open *XATMI*, *XA*, *TX* standards. Each of the systems
implement extensions over theses APIs. For example Tuxedo have *FML* key-value
structure format handling API. Enduro/X counterpart for this functionality is
*UBF* buffers which even provide emulation for *FML* via *fml.h* and *fml32.h*
headers shipped with Enduro/X.

Enduro/X tends to implement most majority of the C APIs which are typically used in
Tuxedo application. To verify your application compatibility with Enduro/X, 
perform manual scan over your code base and check each Tuxedo API in Enduro/X
documentation.

Enduro/X uses different configuration file formats than Tuxedo, however majority
of the configuration concepts are the same.

Enduro/X provides tool *tmloadcf(8)* which allows to automatically convert Tuxedo
UBB configuration.


== API compatibility aspects

Mostly all XATMI/FML calls are supported by Enduro/X with the same logic and
parameters. This section lists some (but not all) known differences:

- *tpgetctxt(3)* Enduro/X version after the call puts current thread outside
of any context association.


== Migration process
...

=== Automatic configuration migration
...

=== Manual configuration migration

Even if configuration is being migrated by automatic approach, it is worth to
read this section. This allows get solid understand of the Enduro/X concepts by using
existing Tuxedo knowledge.

If looking on Tuxedo UBBCONFIG and Enduro/X ndrxconfig.xml/app.ini, then following
similarities projects:

.UBBConfig - Enduro/X section mapping
[width="80%", options="header"]
|=========================================================
|Ubb config section|Enduro/X ndrxconfig.xml|Enduro/X app.ini|Comments
|*RESOURCES|-|[@global] section|Approximate mapping
|*MACHINES|-|[@global], [@debug] path related infos|Approximate mapping
|*GROUPS|-|[@global/<CCTAG>] - global settings per tag, [@queue/<CCTAG>] - persistent
queue configuration per tag.|Approximate mapping
|*NETWORK|Bridge is established as *tpbridge(8)* XATMI server 
processes in <servers> section|-|Approximate mapping
|*SERVERS|<endurox>/<servers> tag |-|-
|*SERVERS server|<endurox>/<servers>/<server name="server"> tag |-|-
|*SERVERS DEFAULT:|<endurox>/<defaults> tag |-|-
|*SERVICES|<endurox>/<services>|-|Service settings are global per instance, i.e.
cannot be configured per cctag.
|*SERVICES service|<endurox>/<services>/<service svcnm="service">|-|-
|*SERVICES DEFAULT:|<endurox>/<services>/<defaults>|-|-
|*ROUTING|<endurox>/<routing>|-|Defaults not supported at this section.
|*ROUTING route|<endurox>/<routing>/<route routing="route">|-|-
|=========================================================

.Tuxedo - Enduro/X key binaries mapping
[width="80%", options="header"]
|=========================================================
|Tuxedo binary|Enduro/X equivalent|Comments
|tmadmin|xadmin|There are set of common commands, like psc, start, etc.
|BBL, DBBBL|ndrxd|
|tlisten|tpbridge|Enduro/X binary is booted as a normal XATMI binary, i.e.
it is not required to start it before application boots
|TMSYSEVT,TMUSEREV|tpevsrv|Also Enduro/X event server is booted as a normal
XATMI binary.
|TMS|tmsrv|Enduro/X version of *tmsrv* supports loading XA switches via shared
libraries. So it is possible to configure *tmsrv* instances for different resources
without need to perform *buildtms(8)*. Enduro/X supports Tuxedo mode too, when
transaction manager is built for particular resource manager.
|=========================================================

=== Creating base configuration for Enduro/X

It is recommended to create base configuration for Enduro/X which is then amended
to match the migrated system setup.

In order to create a working instance of the Enduro/X application, you may use
following command:

--------------------------------------------------------------------------------

$ xadmin provision

--------------------------------------------------------------------------------

This will create base system layout, including directories and configuration files
such as:

- ndrxconfig.xml
- app.ini
- settest1 (environment loader)

For further document we assume that system code "test1" is used.

=== UBB Configuration vs Enduro/X ini/xml format

*Tuxedo* use UBB configuration file, which is kind of extended ini file. This
describes majority of information used for Tuxedo application instance.

Other hand *Enduro/X* uses two separate files for the configuration. One is
XML configuration file (*ndrxconfig.xml(5)* typically) which describes the XATMI
server and client processes, services and DDR info. The other file is standard 
*ini* file (typically *app.ini*) which include per binary configuration.

Typically Enduro/X application are configure with third environment file
which loads the env variables in the shell session. File name typically
starts with *set*.

=== Converting "*RESOURCES" section

Enduro/X resources shall be configured according to the *ex_env(5)* manpage. This
section lists elements with the same or close meaning. Enduro/X setting
is written in *app.ini* in *[@global]* or *[@global/<CCTAG>]* section.

.Tuxedo - Enduro/X resources mapping
[options="header"]
|=========================================================
|Tuxedo setting|Enduro/X equivalent|Comments
|IPCKEY|NDRX_IPCKEY|System wide IPC (shm, msg, sem) identifier offset.
This is hex value. For Enduro/X *0x* or *0X* prefix must not be present in value.
| MAXSERVERS | NDRX_SRVMAX | Max number of servers instance can handle
| MAXSERVICES | NDRX_SVCMAX | Max number of services instance can handle.
For Enduro/X bigger number (something like x2) is recommended, so that linear
hashing/service lookup would work faster.
|SCANUNIT, BLOCKTIME | NDRX_TOUT | In Enduro/X timeouts are configured in single
variable, set in seconds. Can be converted as NDRX_TOUT=(Tux SCANUNIT) * (Tux BLOCKTIME).
|SCANUNIT| NDRX_SCANUNIT| In case if using *SystemV* release (AIX pre 7.3, Solaris),
Enduro/X binaries internally by additional thread scan for timeouts in the local
process. The scanning is done by *NDRX_SCANUNIT* setting (in milliseconds), which
by default is *1000*. For Linux, FreeBSD, MacOS release these is not applicable.
|MAXRTDATA|NDRX_RTCRTMAX|Number of bytes available for routing criterion storage.
|=========================================================

=== Converting "*MACHINES" section

In Enduro/X normally it each configuration set applies only to one machine/instance.
So in Enduro/X there is no such direct equivalent to this section. However some
useful information is encoded in Tuxedo counter part.

When converting multi-server UBBConfig file, it is needed to split all the resources
in UBBConfig by *LMID*. For following UBB sections that could be done via *GROUP*
setting.

If converting single machine (or multiple machines and working in different directories
for each set of the files), then output files may be named as

. set<lmid_lowercase>

. ndrxconfig.xml

. app.ini

In case if converting multiple machines in the same configuration directories,
following configuration naming strategy shall be used:

. set<lmid_lowercase>

. ndrxconfig.<lmid_lowercase>.xml

. app.<lmid_lowercase>.ini

Following information from "*MACHINES" section projects to Enduro/X:

*settest1*:

--------------------------------------------------------------------------------

#/bin/bash
#
# @(#) Load this script in environment before Enduro/X start
#

# update to correspond actual Enduro/X installation path
export NDRX_HOME=/usr
export NDRX_APPHOME=<Common part between APPDIR and TUXCONFIG, if not common part, just use APPDIR >
export NDRX_CCONFIG=<Directory name of TUXCONFIG>
export CDPATH=$CDPATH:.:${NDRX_APPHOME}
export PATH=$PATH:<APPDIR>

--------------------------------------------------------------------------------

Additionally dirname of UBB *ULOGPFX* can be used as [@global]/NDRX_ULOG. Where
later *NDRX_ULOG* by it self means a directory where ULOG files are written by
mask 'ULOG.YYYYMMDD' and process debug logging is written.

Data from UBB *ENVFILE* may be copied to *app.ini* [@global] section.

The above is just recommended way how to setup runtime environment. Other
approaches may be used too, according to *ex_env(5)* and 
*getting_started_tutorial(guides)(Getting Started Tutorial)*.

So if having Tuxedo configuration like:

--------------------------------------------------------------------------------

*MACHINES
"SOME-MACHINE"  LMID=TEST1
        TUXDIR="/some/folder/tuxedo12"
        APPDIR="/user90/bin"
        TUXCONFIG="/user90/conf/tuxconfig"
        ULOGPFX="/user90/log/ULOG"
        TLOGDEVICE="/user90/conf/TLOG"
        ENVFILE="./env_common.txt" 

--------------------------------------------------------------------------------

That would be projected as following Enduro/X *set* file (*settest1*):

--------------------------------------------------------------------------------

# update to correspond actual Enduro/X installation path
export NDRX_HOME=/usr
export NDRX_APPHOME=/user90
export NDRX_CCONFIG=${NDRX_APPHOME}/conf/app.ini
export CDPATH=$CDPATH:.:${NDRX_APPHOME}
export PATH=$PATH:${NDRX_APPHOME}/bin

--------------------------------------------------------------------------------

Additionally *app.ini* would get:

--------------------------------------------------------------------------------

[@global]
...
NDRX_ULOG=${NDRX_APPHOME}/log

# + any data from ENVFILE, directly copied here, as syntax basically is the same

--------------------------------------------------------------------------------

=== Converting "*GROUPS" section

Tuxedo groups can be replaced with Enduro/X CCTAGs. CCTAG basically instructs
processes that during XATMI initialization, library shall read specific parts
from the *app.ini* configuration file. Mainly data encoded in Tuxedo "\*GROUPS"
entry matches to the *[@global/<CCTAG>]* subsection.

Few more differences:

. Tuxedo's *SRVID* shall be unique within group, in Enduro/X *<srvid />* setting
must be unique at instance level.

. In Enduro/X CCTAGs cannot be used to encode two or more instances in one configuration
file. If several cluster instances must be configured, then configuration must
be split and separate set/ini/xml files shall be produced according to *LMID* setting.

. Enduro/X CCTAGs may not be used to put processes in backup groups. The migration
tool when processing such groups, only first identifier value for *LMID* is used.

. In case if XA processing and DDR is not performed by the group, the CCTAG
is not needed to be assigned to the process. The process may be removed from
CCTAG (if default was used) the empty *<cctag />* setting may be used under the *<server />* tag.

.Tuxedo - Enduro/X group mapping
[options="header"]
|=========================================================
|Tuxedo setting|Enduro/X equivalent|Comments
|GRPNO| app.ini: [@global/<CCTAG>]/NDRX_XA_RES_ID=__GRPNO__| Shall be set only if group fines XA resource

|TMSNAME| ndrxconfig.xml: <endurox>/<servers>/<server name="'TMSNAME'">| If 'TMSNAME' name is *TMS*, then *tmsrv*
name shall be used.  For null XA switch groups *app.ini* 
*[@global/CCTAG]/NDRX_XA_DRIVERLIB*  shall be set to *libndrxxanulls.so*.

For /Q queues, *[@global/CCTAG]/NDRX_XA_DRIVERLIB* shall be set to *libndrxxaqdisks.so*
and *[@global/CCTAG]/NDRX_XA_RMLIB* shall be set to *libndrxxaqdisk.so*.

For all other XA groups, *[@global/CCTAG]/NDRX_XA_DRIVERLIB* shall be set to 
*libndrxxatmsx.so* to use built-in xa switch.

|TMSCOUNT|ndrxconfig.xml: 
<endurox>/<servers>/<server name="_TMSNAME_">/<min>__TMSCOUNT__</min> 
and
<endurox>/<servers>/<server name="_TMSNAME_">/<max>__TMSCOUNT__</max>|
Configures TMSRV number of copies. In Enduro/X
this is configured in the same way as all other XA servers.

|OPENINFO| app.ini: [@global/<CCTAG>]/NDRX_XA_OPEN_STR=__OPENINFO__|When converting from
Tuxedo, the XA vendors interface name with colon (:) must be stripped from the value
copied to app.ini

|CLOSEINFO|app.ini: [@global/<CCTAG>]/NDRX_XA_CLOSE_STR=__CLOSEINFO__|When converting from
Tuxedo, the XA vendors interface name with colon (:) must be stripped from the value
copied to app.ini. If not info is required by XA switch vendor, value "-" shall be used.

|ENVFILE|ndrxconfig.xml: <endurox>/<servers>/<server>/<env>__ENVFILE__</env>
or <endurox>/<defaults>/<env>__ENVFILE__</env>|

|Group participates in DDR|app.ini: [@global/<CCTAG>]/NDRX_RTGRP=_GROUP_NAME_|
*Note:* The routing group name with any service name in the grouting group, must not
exceed *29* symbols. 
|=========================================================

Next chapter show by example how Tuxedo groups are converted to Enduro/X configuration.

==== Converting XA NULL group
TODO:

==== Converting /Q XA group
TODO:

==== Converting normal XA group
TODO:    

=== Service dispatching

By default in Tuxedo, if *RQADDR* setting is not configured, each server have
it's own request queue, where then in round-robin or similar fashion requests
from ATMI clients are dispatched. If *RQADDR* is configured, then 
services may work in Multiple Servers, Single Queue (*MSSQ*) model. However,
here requirement is that these servers listening one queue have all the same
services.

In Enduro/X when working in Linux (and FreeBSD), by default all 
services operate in *MSSQ* mode. Basically in Enduro/X each service 
is queue were several executables perform epoll() + EPOLLEXCLUSIVE 
listing on messages. Result is that different servers may have
different sets of services (including shared set of services) and on these shared
services effectively *MSSQ* mode will work out-of-the-box.

On IBM AIX and Oracle Solaris *<rqaddr />* principle may be used in the same way
as Tuxedo does. For MacOS *<rqaddr />* is not available and request dispatching
is done in round-robin fashion only.

=== Clustering

In Enduro/X applications each instance works as "master" node, forming
a peer to peer cluster. This means that each cluster node needs to be started
separately in opposite to Tuxedo, where cluster application is started from
master node, and secondary nodes are started by the master.

Enduro/X cluster works in similar fashion as Tuxedo Gateway, except that
*tpforward(3)* and all other APIs work in the same mode as Tuxedo's multi-machine
configuration (i.e. MODEL=MP).

=== Cluster connectivity

In Tuxedo, on each server *tlisten* binary shall be started which listens for
any other node to connect. In Tuxedo this binary must be started before Tuxedo
is booted.

In Enduro/X each cluster link (between this and other nodes) must be defined in 
*<servers />* as a normal ATMI server. The server process is *tpbridge(8)*. In one
node listening/binding address/port must be set, in other node client mode shall
be configured to connect to first node.

If node *1* shall be connected to nodes *2* and *3*, then on node *1*, two 
*tpbridge* process shall be configured, to establish links to nodes *2* and *3*.

In Enduro/X cluster each server is identified with unique number in range for
1..32, set in *NDRX_NODEID* parameter. This similar to Tuxedo's *LMID*, but
value is strinctly limited to numbers only.

=== Transaction management

While both platforms provide distributed transaction processing APIs and both
perform according to X/Open XA protocol, internally architecture for both products
are different. Key aspects are mentioned here:

- Log format

- Transaction managers

- Recovery


== Tuxedo connectivity and bindings

- Enduro/X does not have *WebLogic Tuxedo Connector* or *Jolt* libraries
for Java. But Enduro/X provides Web Services interface module *endurox-connect*,
particularly *restincl(8)* from which XATMI services can be exposed as JSONS 
web services. With this Enduro/X services may be called from any language which supports web
services. Web services API provides capability for managing global transactions.

- Enduro/X counterpart to the Tuxedo *SALT* is endurox-connect module. The
*restincl(8)* serves the inbound web services traffic and *restousv(8)* services
the outbound traffic. The message formats between *SALT* and *endurox-connect*
are different. Enduro/X counter part tends to use *JSON* message formats. However
*restincl* is extensible and provides general purpose module for incoming
web traffic handling from XATMI perspective (this includes any kind of web traffic
handling, file upload, custom message formats, etc.).

- *endurox-java* package serves as direct counterpart of the *Oracle Tuxedo Java*. Some
of the APIs are different, but majority conforms to the *TJATMI*. Enduro/X implementation
is based on JNI binding code. Each java instance is started as separate binary.


////////////////////////////////////////////////////////////////
The index is normally left completely empty, it's contents being
generated automatically by the DocBook toolchain.
////////////////////////////////////////////////////////////////

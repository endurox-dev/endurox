<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Pscript 3.0 Reference Manual</title><link rel="stylesheet" href="pscript.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.62.4"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e2"></a>Pscript 3.0 Reference Manual</h1></div><div><h2 class="subtitle">version 3.0.7 release stable</h2></div><div><div class="author"><h3 class="author"><span class="firstname">Alberto</span> <span class="surname">Demichelis</span></h3></div></div><div><p class="othercredit"><span class="contrib">Extensive review</span>: <span class="firstname">Wouter</span> <span class="surname">Van Oortmersern</span></p></div><div><p class="copyright">Copyright &copy; 2003-2015 Alberto Demichelis</p></div><div><div class="legalnotice"><p>
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:</p><p>The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.</p><p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.</p></div></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#d0e33">1. Introduction</a></span></dt><dt><span class="chapter"><a href="#d0e39">2. The language</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e45">Lexical structure</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e49">Identifiers</a></span></dt><dt><span class="sect2"><a href="#d0e61">Keywords</a></span></dt><dt><span class="sect2"><a href="#d0e183">Operators</a></span></dt><dt><span class="sect2"><a href="#d0e291">Other tokens</a></span></dt><dt><span class="sect2"><a href="#d0e335">Literals</a></span></dt><dt><span class="sect2"><a href="#d0e410">Comments</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e448">Values and Data types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e457">Integer</a></span></dt><dt><span class="sect2"><a href="#d0e465">Float</a></span></dt><dt><span class="sect2"><a href="#d0e473">String</a></span></dt><dt><span class="sect2"><a href="#d0e492">Null</a></span></dt><dt><span class="sect2"><a href="#d0e500">Bool</a></span></dt><dt><span class="sect2"><a href="#d0e514">Table</a></span></dt><dt><span class="sect2"><a href="#d0e522">Array</a></span></dt><dt><span class="sect2"><a href="#d0e530">Function</a></span></dt><dt><span class="sect2"><a href="#d0e536">Class</a></span></dt><dt><span class="sect2"><a href="#d0e542">Class instance</a></span></dt><dt><span class="sect2"><a href="#d0e551">Generator</a></span></dt><dt><span class="sect2"><a href="#d0e560">Userdata</a></span></dt><dt><span class="sect2"><a href="#d0e569">Thread</a></span></dt><dt><span class="sect2"><a href="#d0e575">Weak References</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e584">Execution Context</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e599">Variables</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e654">Statements</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e668">Block</a></span></dt><dt><span class="sect2"><a href="#d0e680">Control Flow Statements</a></span></dt><dt><span class="sect2"><a href="#d0e758">Loops</a></span></dt><dt><span class="sect2"><a href="#d0e790">break</a></span></dt><dt><span class="sect2"><a href="#d0e802">continue</a></span></dt><dt><span class="sect2"><a href="#d0e814">return</a></span></dt><dt><span class="sect2"><a href="#d0e826">yield</a></span></dt><dt><span class="sect2"><a href="#d0e841">Local variables declaration</a></span></dt><dt><span class="sect2"><a href="#d0e855">Function declaration</a></span></dt><dt><span class="sect2"><a href="#d0e867">Class declaration</a></span></dt><dt><span class="sect2"><a href="#d0e879">try/catch</a></span></dt><dt><span class="sect2"><a href="#d0e891">throw</a></span></dt><dt><span class="sect2"><a href="#d0e903">const</a></span></dt><dt><span class="sect2"><a href="#d0e919">enum</a></span></dt><dt><span class="sect2"><a href="#d0e936">expression statement</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e948">Expressions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e955">Assignment(=) &amp; new slot(&lt;-)</a></span></dt><dt><span class="sect2"><a href="#d0e987">Operators</a></span></dt><dt><span class="sect2"><a href="#d0e1216">Table constructor</a></span></dt><dt><span class="sect2"><a href="#d0e1274">clone</a></span></dt><dt><span class="sect2"><a href="#d0e1299">Array constructor</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e1317">Tables</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1327">Construction</a></span></dt><dt><span class="sect2"><a href="#d0e1336">Slot creation</a></span></dt><dt><span class="sect2"><a href="#d0e1361">Slot deletion</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e1377">Arrays</a></span></dt><dt><span class="sect1"><a href="#d0e1393">Functions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1403">Function declaration</a></span></dt><dt><span class="sect2"><a href="#d0e1470">Function calls</a></span></dt><dt><span class="sect2"><a href="#d0e1496">Binding an environment to a function</a></span></dt><dt><span class="sect2"><a href="#d0e1514">Lambda expressions</a></span></dt><dt><span class="sect2"><a href="#d0e1556">Free variables</a></span></dt><dt><span class="sect2"><a href="#d0e1569">Tail recursion</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e1580">Classes</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1590">Class declaration</a></span></dt><dt><span class="sect2"><a href="#d0e1672">Class instances</a></span></dt><dt><span class="sect2"><a href="#d0e1738">Inheritance</a></span></dt><dt><span class="sect2"><a href="#d0e1779">Metamethods</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e1827">Generators</a></span></dt><dt><span class="sect1"><a href="#d0e1858">Constants &amp; Enumerations</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1869">Constants</a></span></dt><dt><span class="sect2"><a href="#d0e1892">Enumerations</a></span></dt><dt><span class="sect2"><a href="#d0e1924">Implementation notes</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e1954">Threads</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1965">Using threads</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e1995">Weak References</a></span></dt><dt><span class="sect1"><a href="#d0e2038">Delegation</a></span></dt><dt><span class="sect1"><a href="#d0e2057">Metamethods</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e2079">_set</a></span></dt><dt><span class="sect2"><a href="#d0e2092">_get</a></span></dt><dt><span class="sect2"><a href="#d0e2105">_newslot</a></span></dt><dt><span class="sect2"><a href="#d0e2120">_delslot</a></span></dt><dt><span class="sect2"><a href="#d0e2135">_add</a></span></dt><dt><span class="sect2"><a href="#d0e2148">_sub</a></span></dt><dt><span class="sect2"><a href="#d0e2159">_mul</a></span></dt><dt><span class="sect2"><a href="#d0e2170">_div</a></span></dt><dt><span class="sect2"><a href="#d0e2181">_modulo</a></span></dt><dt><span class="sect2"><a href="#d0e2192">_unm</a></span></dt><dt><span class="sect2"><a href="#d0e2205">_typeof</a></span></dt><dt><span class="sect2"><a href="#d0e2218">_cmp</a></span></dt><dt><span class="sect2"><a href="#d0e2263">_call</a></span></dt><dt><span class="sect2"><a href="#d0e2276">_cloned</a></span></dt><dt><span class="sect2"><a href="#d0e2289">_nexti</a></span></dt><dt><span class="sect2"><a href="#d0e2304">_tostring</a></span></dt><dt><span class="sect2"><a href="#d0e2322">_inherited</a></span></dt><dt><span class="sect2"><a href="#d0e2343">_newmember</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e2358">Built-in functions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e2365">Global symbols</a></span></dt><dt><span class="sect2"><a href="#d0e2615">Default delegates</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e3772">3. Embedding Pscript</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e3783">Memory management</a></span></dt><dt><span class="sect1"><a href="#d0e3800">Unicode</a></span></dt><dt><span class="sect1"><a href="#d0e3806">Pscript on 64 bits architectures</a></span></dt><dt><span class="sect1"><a href="#d0e3811">Userdata alignment</a></span></dt><dt><span class="sect1"><a href="#d0e3819">Stand-alone VM without compiler</a></span></dt><dt><span class="sect1"><a href="#d0e3825">Error conventions</a></span></dt><dt><span class="sect1"><a href="#d0e3833">Initializing Pscript</a></span></dt><dt><span class="sect1"><a href="#d0e3849">The Stack</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e3855">Stack indexes</a></span></dt><dt><span class="sect2"><a href="#d0e3933">Stack manipulation</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e4000">Runtime error handling</a></span></dt><dt><span class="sect1"><a href="#d0e4011">Compiling a script</a></span></dt><dt><span class="sect1"><a href="#d0e4046">Calling a function</a></span></dt><dt><span class="sect1"><a href="#d0e4060">Create a C function</a></span></dt><dt><span class="sect1"><a href="#d0e4108">Tables and arrays manipulation</a></span></dt><dt><span class="sect1"><a href="#d0e4177">Userdata and UserPointers</a></span></dt><dt><span class="sect1"><a href="#d0e4201">The registry table</a></span></dt><dt><span class="sect1"><a href="#d0e4213">Mantaining strong references to Pscript values from the C API</a></span></dt><dt><span class="sect1"><a href="#d0e4221">Debug Interface</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e4257">4. API Reference</a></span></dt><dt><span class="index"><a href="#d0e11543">Index</a></span></dt></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e33"></a>Chapter&nbsp;1.&nbsp;Introduction</h2></div></div><div></div></div><p>
		Pscript is a high level imperative-OO programming language, designed to be a powerful
		scripting tool that fits in the size, memory bandwidth, and real-time requirements of
		applications like games.
		Although Pscript offers a wide range of features like dynamic typing, delegation, higher
		order functions, generators, tail recursion, exception handling, automatic memory
		management, both compiler and virtual machine fit together in about 6k lines of C++
		code.
	</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e39"></a>Chapter&nbsp;2.&nbsp;The language</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#d0e45">Lexical structure</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e49">Identifiers</a></span></dt><dt><span class="sect2"><a href="#d0e61">Keywords</a></span></dt><dt><span class="sect2"><a href="#d0e183">Operators</a></span></dt><dt><span class="sect2"><a href="#d0e291">Other tokens</a></span></dt><dt><span class="sect2"><a href="#d0e335">Literals</a></span></dt><dt><span class="sect2"><a href="#d0e410">Comments</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e448">Values and Data types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e457">Integer</a></span></dt><dt><span class="sect2"><a href="#d0e465">Float</a></span></dt><dt><span class="sect2"><a href="#d0e473">String</a></span></dt><dt><span class="sect2"><a href="#d0e492">Null</a></span></dt><dt><span class="sect2"><a href="#d0e500">Bool</a></span></dt><dt><span class="sect2"><a href="#d0e514">Table</a></span></dt><dt><span class="sect2"><a href="#d0e522">Array</a></span></dt><dt><span class="sect2"><a href="#d0e530">Function</a></span></dt><dt><span class="sect2"><a href="#d0e536">Class</a></span></dt><dt><span class="sect2"><a href="#d0e542">Class instance</a></span></dt><dt><span class="sect2"><a href="#d0e551">Generator</a></span></dt><dt><span class="sect2"><a href="#d0e560">Userdata</a></span></dt><dt><span class="sect2"><a href="#d0e569">Thread</a></span></dt><dt><span class="sect2"><a href="#d0e575">Weak References</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e584">Execution Context</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e599">Variables</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e654">Statements</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e668">Block</a></span></dt><dt><span class="sect2"><a href="#d0e680">Control Flow Statements</a></span></dt><dt><span class="sect2"><a href="#d0e758">Loops</a></span></dt><dt><span class="sect2"><a href="#d0e790">break</a></span></dt><dt><span class="sect2"><a href="#d0e802">continue</a></span></dt><dt><span class="sect2"><a href="#d0e814">return</a></span></dt><dt><span class="sect2"><a href="#d0e826">yield</a></span></dt><dt><span class="sect2"><a href="#d0e841">Local variables declaration</a></span></dt><dt><span class="sect2"><a href="#d0e855">Function declaration</a></span></dt><dt><span class="sect2"><a href="#d0e867">Class declaration</a></span></dt><dt><span class="sect2"><a href="#d0e879">try/catch</a></span></dt><dt><span class="sect2"><a href="#d0e891">throw</a></span></dt><dt><span class="sect2"><a href="#d0e903">const</a></span></dt><dt><span class="sect2"><a href="#d0e919">enum</a></span></dt><dt><span class="sect2"><a href="#d0e936">expression statement</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e948">Expressions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e955">Assignment(=) &amp; new slot(&lt;-)</a></span></dt><dt><span class="sect2"><a href="#d0e987">Operators</a></span></dt><dt><span class="sect2"><a href="#d0e1216">Table constructor</a></span></dt><dt><span class="sect2"><a href="#d0e1274">clone</a></span></dt><dt><span class="sect2"><a href="#d0e1299">Array constructor</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e1317">Tables</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1327">Construction</a></span></dt><dt><span class="sect2"><a href="#d0e1336">Slot creation</a></span></dt><dt><span class="sect2"><a href="#d0e1361">Slot deletion</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e1377">Arrays</a></span></dt><dt><span class="sect1"><a href="#d0e1393">Functions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1403">Function declaration</a></span></dt><dt><span class="sect2"><a href="#d0e1470">Function calls</a></span></dt><dt><span class="sect2"><a href="#d0e1496">Binding an environment to a function</a></span></dt><dt><span class="sect2"><a href="#d0e1514">Lambda expressions</a></span></dt><dt><span class="sect2"><a href="#d0e1556">Free variables</a></span></dt><dt><span class="sect2"><a href="#d0e1569">Tail recursion</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e1580">Classes</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1590">Class declaration</a></span></dt><dt><span class="sect2"><a href="#d0e1672">Class instances</a></span></dt><dt><span class="sect2"><a href="#d0e1738">Inheritance</a></span></dt><dt><span class="sect2"><a href="#d0e1779">Metamethods</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e1827">Generators</a></span></dt><dt><span class="sect1"><a href="#d0e1858">Constants &amp; Enumerations</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1869">Constants</a></span></dt><dt><span class="sect2"><a href="#d0e1892">Enumerations</a></span></dt><dt><span class="sect2"><a href="#d0e1924">Implementation notes</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e1954">Threads</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1965">Using threads</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e1995">Weak References</a></span></dt><dt><span class="sect1"><a href="#d0e2038">Delegation</a></span></dt><dt><span class="sect1"><a href="#d0e2057">Metamethods</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e2079">_set</a></span></dt><dt><span class="sect2"><a href="#d0e2092">_get</a></span></dt><dt><span class="sect2"><a href="#d0e2105">_newslot</a></span></dt><dt><span class="sect2"><a href="#d0e2120">_delslot</a></span></dt><dt><span class="sect2"><a href="#d0e2135">_add</a></span></dt><dt><span class="sect2"><a href="#d0e2148">_sub</a></span></dt><dt><span class="sect2"><a href="#d0e2159">_mul</a></span></dt><dt><span class="sect2"><a href="#d0e2170">_div</a></span></dt><dt><span class="sect2"><a href="#d0e2181">_modulo</a></span></dt><dt><span class="sect2"><a href="#d0e2192">_unm</a></span></dt><dt><span class="sect2"><a href="#d0e2205">_typeof</a></span></dt><dt><span class="sect2"><a href="#d0e2218">_cmp</a></span></dt><dt><span class="sect2"><a href="#d0e2263">_call</a></span></dt><dt><span class="sect2"><a href="#d0e2276">_cloned</a></span></dt><dt><span class="sect2"><a href="#d0e2289">_nexti</a></span></dt><dt><span class="sect2"><a href="#d0e2304">_tostring</a></span></dt><dt><span class="sect2"><a href="#d0e2322">_inherited</a></span></dt><dt><span class="sect2"><a href="#d0e2343">_newmember</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e2358">Built-in functions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e2365">Global symbols</a></span></dt><dt><span class="sect2"><a href="#d0e2615">Default delegates</a></span></dt></dl></dd></dl></div><p>
		This part of the document describes the syntax and semantics of the language.
	</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e45"></a>Lexical structure</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e49"></a>Identifiers</h3></div></div><div></div></div><a class="indexterm" name="d0e50"></a><p>
				Identifiers start with a alphabetic character or '_' followed by any number of alphabetic
				characters, '_' or digits ([0-9]). Pscript is a case sensitive language, this means that the
				lowercase and uppercase representation of the same alphabetic character are considered
				different characters. For instance "foo", "Foo" and "fOo" will be treated as 3 distinct
				identifiers.
			</p><pre class="programlisting"><span class="emphasis"><em>id:= [a-zA-Z_]+[a-zA-Z_0-9]*</em></span></pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e61"></a>Keywords</h3></div></div><div></div></div><a class="indexterm" name="d0e62"></a><p>
				The following words are reserved words by the language and cannot be used as
				identifiers:
			</p><div class="informaltable"><table border="0"><colgroup><col><col><col><col><col><col></colgroup><tbody><tr><td><tt class="literal">base</tt></td><td><tt class="literal">break</tt></td><td><tt class="literal">case</tt></td><td><tt class="literal">catch</tt></td><td><tt class="literal">class</tt></td><td><tt class="literal">clone</tt></td></tr><tr><td><tt class="literal">continue</tt></td><td><tt class="literal">const</tt></td><td><tt class="literal">default</tt></td><td><tt class="literal">delete</tt></td><td><tt class="literal">else</tt></td><td><tt class="literal">enum</tt></td></tr><tr><td><tt class="literal">extends</tt></td><td><tt class="literal">for</tt></td><td><tt class="literal">foreach</tt></td><td><tt class="literal">function</tt></td><td><tt class="literal">if</tt></td><td><tt class="literal">in</tt></td></tr><tr><td><tt class="literal">local</tt></td><td><tt class="literal">null</tt></td><td><tt class="literal">resume</tt></td><td><tt class="literal">return</tt></td><td><tt class="literal">switch</tt></td><td><tt class="literal">this</tt></td></tr><tr><td><tt class="literal">throw</tt></td><td><tt class="literal">try</tt></td><td><tt class="literal">typeof</tt></td><td><tt class="literal">while</tt></td><td><tt class="literal">yield</tt></td><td><tt class="literal">constructor</tt></td></tr><tr><td><tt class="literal">instanceof</tt></td><td><tt class="literal">true</tt></td><td><tt class="literal">false</tt></td><td><tt class="literal">static</tt></td><td class="auto-generated">&nbsp;</td><td class="auto-generated">&nbsp;</td></tr></tbody></table></div><p>
				Keywords are covered in detail later in this document.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e183"></a>Operators</h3></div></div><div></div></div><a class="indexterm" name="d0e184"></a><p>
				Pscript recognizes the following operators:
			</p><div class="informaltable"><table border="0"><colgroup><col><col><col><col><col><col><col><col></colgroup><tbody><tr><td><tt class="literal">! </tt></td><td><tt class="literal">!= </tt></td><td><tt class="literal">|| </tt></td><td><tt class="literal">== </tt></td><td><tt class="literal">&amp;&amp; </tt></td><td><tt class="literal">&lt;= </tt></td><td><tt class="literal">=&gt; </tt></td><td><tt class="literal">&gt; </tt></td></tr><tr><td><tt class="literal">&lt;=&gt;</tt></td><td><tt class="literal">+ </tt></td><td><tt class="literal">+= </tt></td><td><tt class="literal">- </tt></td><td><tt class="literal">-= </tt></td><td><tt class="literal">/ </tt></td><td><tt class="literal">/= </tt></td><td><tt class="literal">* </tt></td></tr><tr><td><tt class="literal">*= </tt></td><td><tt class="literal">% </tt></td><td><tt class="literal">%= </tt></td><td><tt class="literal">++ </tt></td><td><tt class="literal">-- </tt></td><td><tt class="literal">&lt;- </tt></td><td><tt class="literal">= </tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td><tt class="literal">&amp; </tt></td><td><tt class="literal">^ </tt></td><td><tt class="literal">| </tt></td><td><tt class="literal">~ </tt></td><td><tt class="literal">&gt;&gt; </tt></td><td><tt class="literal">&lt;&lt; </tt></td><td><tt class="literal">&gt;&gt;&gt; </tt></td><td><tt class="literal"></tt></td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e291"></a>Other tokens</h3></div></div><div></div></div><p>
				Other used tokens are:
			</p><div class="informaltable"><table border="0"><colgroup><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><tbody><tr><td><tt class="literal">{</tt></td><td><tt class="literal">}</tt></td><td><tt class="literal">[</tt></td><td><tt class="literal">]</tt></td><td><tt class="literal">.</tt></td><td><tt class="literal">:</tt></td><td><tt class="literal">::</tt></td><td><tt class="literal">'</tt></td><td><tt class="literal">;</tt></td><td><tt class="literal">"</tt></td><td><tt class="literal">@"</tt></td><td class="auto-generated">&nbsp;</td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e335"></a>Literals</h3></div></div><div></div></div><a class="indexterm" name="d0e336"></a><p>
				Pscript accepts integer numbers, floating point numbers and strings literals.
			</p><div class="informaltable"><table border="0"><colgroup><col><col></colgroup><tbody><tr><td><tt class="literal">34</tt></td><td>Integer number(base 10)</td></tr><tr><td><tt class="literal">0xFF00A120</tt></td><td>Integer number(base 16)</td></tr><tr><td><tt class="literal">0753</tt></td><td>Integer number(base 8)</td></tr><tr><td><tt class="literal">'a'</tt></td><td>Integer number</td></tr><tr><td><tt class="literal">1.52</tt></td><td>Floating point number</td></tr><tr><td><tt class="literal">1.e2</tt></td><td>Floating point number</td></tr><tr><td><tt class="literal">1.e-2</tt></td><td>Floating point number</td></tr><tr><td><tt class="literal">"I'm a string"</tt></td><td>String</td></tr><tr><td><tt class="literal">@"I'm a verbatim string"</tt></td><td>String</td></tr><tr><td><tt class="literal">
@" I'm a 
	multiline verbatim string
"
							
						</tt></td><td>String</td></tr></tbody></table></div><pre class="programlisting"><span class="emphasis"><em>
IntegerLiteral := [1-9][0-9]* | '0x' [0-9A-Fa-f]+ | ''' [.]+ ''' | 0[0-7]+
FloatLiteral := [0-9]+ '.' [0-9]+
FloatLiteral := [0-9]+ '.' 'e'|'E' '+'|'-' [0-9]+
StringLiteral:= '"'[.]* '"'
VerbatimStringLiteral:= '@''"'[.]* '"'
      </em></span></pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e410"></a>Comments</h3></div></div><div></div></div><a class="indexterm" name="d0e411"></a>
			A comment is text that the compiler ignores but that is useful for programmers. 
			Comments are normally used to embed annotations in the code. The compiler 
			treats them as white space.
			<p>
				The <tt class="literal">/*</tt> (slash, asterisk) characters, followed by any 
				sequence of characters (including new lines), 
				followed by the <tt class="literal">*/</tt> characters. This syntax is the same as ANSI C.
				</p><pre class="programlisting">
/* 
this is
a multiline comment.
this lines will be ignored by the compiler
*/				
				</pre><p>
			</p><p>
				The <tt class="literal">//</tt> (two slashes) characters, followed by any sequence of characters. 
				A new line not immediately preceded by a backslash terminates this form of comment. 
				It is commonly called a <tt class="literal">&#8220;single-line comment.&#8221;</tt> 
				</p><pre class="programlisting">
//this is a single line comment. this line will be ignored by the compiler 
				</pre><p>
			</p><p>
        The character <tt class="literal">#</tt> is an alternative syntax for single line comment.
        </p><pre class="programlisting">
          
#this is also a single line comment.
        </pre><p>
        This to facilitate the use of pscript in UNIX-style shell scripts.
      </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e448"></a>Values and Data types</h2></div></div><div></div></div><a class="indexterm" name="d0e449"></a><p>
			Pscript is a dynamically typed language so variables do not have a type, although they
			refer to a value that does have a type.
			Pscript basic types are integer, float, string, null, table, array, function, generator, 
			class, instance, bool, thread and
			userdata.
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e457"></a>Integer</h3></div></div><div></div></div><p>
				An Integer represents a 32 bits (or better) signed number.
			</p><pre class="programlisting">
local a = 123 //decimal
local b = 0x0012 //hexadecimal
local c = 075 //octal
local d = 'w' //char code
      </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e465"></a>Float</h3></div></div><div></div></div><p>
				A float represents a 32 bits (or better) floating point number.
			</p><pre class="programlisting">
local a=1.0
local b=0.234
			</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e473"></a>String</h3></div></div><div></div></div><p>
				Strings are an immutable sequence of characters to modify a string is necessary create a new one.
			</p><p> Pscript's strings, behave like C or C++, are delimited by quotation marks(") and can contain
			escape sequences(\t,\a,\b,\n,\r,\v,\f,\\,\",\',\0,\x<span class="emphasis"><em>hhhh</em></span>).
			</p><p>Verbatim string literals begin with @" and end with the matching quote.
			Verbatim string literals also can extend over a line break. If they do, they  
			include any white space characters between the quotes:
			</p><pre class="programlisting">
local a = "I'm a wonderful string\n"
// has a newline at the end of the string
local x = @"I'm a verbatim string\n"
// the \n is copied in the string same as \\n in a regular string "I'm a verbatim string\n"
</pre><p>The only exception to the "no escape sequence" rule for verbatim 
string literals is that you can put a double quotation mark inside a 
verbatim string by doubling it:</p><pre class="programlisting">
local multiline = @"
	this is a multiline string
	it will ""embed"" all the new line 
	characters
"
			</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e492"></a>Null</h3></div></div><div></div></div><p>
				The null value is a primitive value that represents the null, empty, or non-existent
				reference. The type Null has exactly one value, called null. 
			</p><pre class="programlisting">
local a=null
			</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e500"></a>Bool</h3></div></div><div></div></div><p>
				the bool data type can have only two. They are the literals <tt class="literal">true</tt>
				and <tt class="literal">false</tt>. A bool value expresses the validity of a condition 
				(tells whether the condition is true or false).
			</p><pre class="programlisting">
local a = true;
			</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e514"></a>Table</h3></div></div><div></div></div><p>
				Tables are associative containers implemented as pairs of key/value (called a slot).
			</p><pre class="programlisting">
local t={}
local test=
{
    a=10
    b=function(a) { return a+1; }
}
			</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e522"></a>Array</h3></div></div><div></div></div><p>
				Arrays are simple sequence of objects, their size is dynamic and their index starts always from 0.
			</p><pre class="programlisting">
local a=["I'm","an","array"]
local b=[null]
b[0]=a[2];
			</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e530"></a>Function</h3></div></div><div></div></div><p>
				Functions are similar to those in other C-like languages and to most programming
				languages in general, however there are a few key differences (see below).
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e536"></a>Class</h3></div></div><div></div></div><p>
				Classes are associative containers implemented as pairs of key/value. Classes are created through
				a 'class expression' or a 'class statement'. class members can be inherited from another class object
				at creation time. After creation members can be added until a instance of the class is created.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e542"></a>Class instance</h3></div></div><div></div></div><p>
				Class instances are created by calling a <tt class="literal">class object</tt>. Instances, as tables, are
				implemented as pair of key/value. Instances members cannot be dyncamically added or removed however 
				the value of the members can be changed.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e551"></a>Generator</h3></div></div><div></div></div><p>
				Generators are functions that can be suspended with the statement 'yield' and resumed
				later (see <a href="#generators">Generators</a>).
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e560"></a>Userdata</h3></div></div><div></div></div><p>
				Userdata objects are blobs of memory(or pointers) defined by the host application but
				stored into Pscript variables (See <a href="#userdandup">Userdata and UserPointers</a>).
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e569"></a>Thread</h3></div></div><div></div></div><p>
				Threads are objects that represents a cooperative thread of execution, also known as coroutines.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e575"></a>Weak References</h3></div></div><div></div></div><p>
				Weak References are objects that point to another(non scalar) object but do not own a strong reference to it.
				(See <a href="#weakrefs">Weak References</a>).
			</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e584"></a>Execution Context</h2></div></div><div></div></div><a class="indexterm" name="d0e585"></a><p>
			The execution context is the union of the function stack frame and the function
			environment object(this).
			The stack frame is the portion of stack where the local variables declared in its body are
			stored.
			The environment object is an implicit parameter that is automatically passed by the
			function caller (see <a href="#functions">Functions</a>).
			During the execution, the body of a function can only transparently refer to his execution
			context. This mean that a single identifier can refer either to a local variable or to an
			environment object slot; Global variables require a special syntax (see <a href="#variables">Variables</a>).
			The environment object can be explicitly accessed by the keyword this.
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e599"></a>Variables</h3></div></div><div></div></div><a name="variables"></a><a class="indexterm" name="d0e601"></a><p>
				There are two types of variables in Pscript, local variables and tables/arrays slots.
				Because global variables are stored in a table, they are table slots.
			</p><p>
				A single identifier refers to a local variable or a slot in the environment object.
			</p><p><tt class="literal">derefexp := id;</tt></p><pre class="programlisting">
_table["foo"]
_array[10]</pre><p>
				with tables we can also use the '.' syntax
			</p><p><tt class="literal">derefexp := exp '.' id </tt></p><pre class="programlisting">
_table.foo</pre><p>
			Pscript first checks if an identifier is a local variable (function arguments are local
			variables) if not it checks if it is a member of the environment object (this).
			</p><p>For instance:</p><pre class="programlisting">
function testy(arg)
{
    local a=10;
    print(a);
    return arg;
}			
			</pre><p>will access to local variable 'a' and prints 10.</p><pre class="programlisting">
function testy(arg)
{
    local a=10;
    return arg+foo;
}
			</pre><p>in this case 'foo' will be equivalent to 'this.foo' or this["foo"].</p><p>
			Global variables are stored in a table called the root table. Usually in the global scope the
			environment object is the root table, but to explicitly access the global table from
			another scope, the slot name must be prefixed with '::' (::foo).
			</p><p><tt class="literal">exp:= '::' id</tt></p><p>For instance:</p><pre class="programlisting">
function testy(arg)
{
    local a=10;
    return arg+::foo;
}
			</pre><p>accesses the global variable 'foo'.</p><p>
			However (since pscript 2.0) if a variable is not local and is not found in the 'this' object Pscript will search it
			in the root table.
</p><pre class="programlisting">
function test() {
	foo = 10;
}
</pre><p>
			is equivalent to write
</p><pre class="programlisting">
function test() {
	if("foo" in this) {
		this.foo = 10;
	}else {
		::foo = 10;
	}
}
</pre><p>
			</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e654"></a>Statements</h2></div></div><div></div></div><a class="indexterm" name="d0e657"></a><p>A pscript program is a simple sequence of statements.</p><pre class="programlisting"><span class="emphasis"><em>stats := stat [';'|'\n'] stats</em></span></pre><p>
			Statements in pscript are comparable to the C-Family languages (C/C++, Java, C#
			etc...): assignment, function calls, program flow control structures etc.. plus some
			custom statement like yield, table and array constructors (All those will be covered in detail
			later in this document).
			Statements can be separated with a new line or ';' (or with the keywords case or default if
			inside a switch/case statement), both symbols are not required if the statement is
			followed by '}'.
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e668"></a>Block</h3></div></div><div></div></div><a class="indexterm" name="d0e669"></a><pre class="programlisting"><span class="emphasis"><em>stat := '{' stats '}'</em></span></pre><p>
				A sequence of statements delimited by curly brackets ({ }) is called block; 
				a block is a statement itself.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e680"></a>Control Flow Statements</h3></div></div><div></div></div><p>
				pscript implements the most common control flow statements: <tt class="literal">if, while, do-while,
				switch-case, for, foreach</tt>.
			</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e688"></a>true and false</h4></div></div><div></div></div><a class="indexterm" name="d0e689"></a><p>
					Pscript has a boolean type(bool) however like C++ it considers null, 0(integer) and 0.0(float)
					as <span class="emphasis"><em>false</em></span>, any other value is considered <span class="emphasis"><em>true</em></span>.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e703"></a>if/else</h4></div></div><div></div></div><a class="indexterm" name="d0e704"></a><pre class="programlisting"><span class="emphasis"><em>stat:= 'if' '(' exp ')' stat ['else' stat]</em></span></pre><p>
					Conditionally execute a statement depending on the result of an expression.
				</p><pre class="programlisting">
if(a&gt;b)
    a=b;
else
    b=a;
////
if(a==10)
{
    b=a+b;
    return a;
}
				</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e718"></a>while</h4></div></div><div></div></div><a class="indexterm" name="d0e719"></a><pre class="programlisting"><span class="emphasis"><em>stat:= 'while' '(' exp ')' stat</em></span></pre><p>Executes a statement while the condition is true.</p><pre class="programlisting">
				
function testy(n)
{
    local a=0;
    while(a&lt;n) a+=1;
	
	while(1)
	{
        if(a&lt;0) break;
        a-=1;
    }
}					
				</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e732"></a>do/while</h4></div></div><div></div></div><a class="indexterm" name="d0e733"></a><pre class="programlisting"><span class="emphasis"><em>stat:= 'do' stat 'while' '(' expression ')'</em></span></pre><p>
					Executes a statement once, and then repeats execution of the statement until a condition
					expression evaluates to false.
				</p><pre class="programlisting">
				
local a=0;
do
{
    print(a+"\n");
    a+=1;
} while(a&gt;100)			
				</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e746"></a>switch</h4></div></div><div></div></div><a class="indexterm" name="d0e747"></a><pre class="programlisting"><span class="emphasis"><em>
stat := 'switch' ''( exp ')' '{'
	'case' case_exp ':'
		stats
	['default' ':'
		stats]
'}'
				</em></span></pre><p>
					Is a control statement allows multiple selections of code by passing control to one of the
					case statements within its body.
					The control is transferred to the case label whose case_exp matches with exp if none of
					the case match will jump to the default label (if present).
					A switch statement can contain any number if case instances, if 2 case have the same
					expression result the first one will be taken in account first. The default label is only
					allowed once and must be the last one.
					A break statement will jump outside the switch block.
				</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e758"></a>Loops</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e762"></a>for</h4></div></div><div></div></div><a class="indexterm" name="d0e763"></a><pre class="programlisting"><span class="emphasis"><em>stat:= 'for' '(' [initexp] ';' [condexp] ';' [incexp] ')' statement</em></span></pre><p>Executes a statement as long as a condition is different than false.</p><pre class="programlisting">
				
for(local a=0;a&lt;10;a+=1)
    print(a+"\n");
//or
glob &lt;- null
for(glob=0;glob&lt;10;glob+=1){
    print(glob+"\n");
}
//or
for(;;){
    print(loops forever+"\n");
}				
				</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e776"></a>foreach</h4></div></div><div></div></div><a class="indexterm" name="d0e777"></a><pre class="programlisting"><span class="emphasis"><em>'foreach' '(' [index_id','] value_id 'in' exp ')' stat</em></span></pre><p>
					Executes a statement for every element contained in an array, table, class, string or generator.
					If exp is a generator it will be resumed every iteration as long as it is alive; the value will
					be the result of 'resume' and the index the sequence number of the iteration starting
					from 0.
				</p><pre class="programlisting">
				
local a=[10,23,33,41,589,56]
foreach(idx,val in a)
    print("index="+idx+" value="+val+"\n");
//or
foreach(val in a)
    print("value="+val+"\n");
				
				</pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e790"></a>break</h3></div></div><div></div></div><a class="indexterm" name="d0e791"></a><pre class="programlisting"><span class="emphasis"><em>stat := 'break'</em></span></pre><p>
				The break statement terminates the execution of a loop (for, foreach, while or do/while)
				or jumps out of switch statement;
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e802"></a>continue</h3></div></div><div></div></div><a class="indexterm" name="d0e803"></a><pre class="programlisting"><span class="emphasis"><em>stat := 'continue'</em></span></pre><p>
				The continue operator jumps to the next iteration of the loop skipping the execution of
				the following statements.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e814"></a>return</h3></div></div><div></div></div><a class="indexterm" name="d0e815"></a><pre class="programlisting"><span class="emphasis"><em>stat:= return [exp]</em></span></pre><p>
				The return statement terminates the execution of the current function/generator and
				optionally returns the result of an expression. If the expression is omitted the function
				will return null. If the return statement is used inside a generator, the generator will not
				be resumable anymore.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e826"></a>yield</h3></div></div><div></div></div><a class="indexterm" name="d0e827"></a><pre class="programlisting"><span class="emphasis"><em>stat := yield [exp]</em></span></pre><p>
				(see <a href="#generators">Generators</a>).
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e841"></a>Local variables declaration</h3></div></div><div></div></div><a class="indexterm" name="d0e842"></a><pre class="programlisting"><span class="emphasis"><em>
initz := id [= exp][',' initz]
stat := 'local' initz
			</em></span></pre><p>
				Local variables can be declared at any point in the program; they exist between their
				declaration to the end of the block where they have been declared.
				EXCEPTION: a local declaration statement is allowed as first expression in a for loop.
			</p><pre class="programlisting">
for(local a=0;a&lt;10;a+=1)
    print(a); 
			</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e855"></a>Function declaration</h3></div></div><div></div></div><a class="indexterm" name="d0e856"></a><pre class="programlisting"><span class="emphasis"><em>
funcname := id ['::' id]
stat:= 'function' id ['::' id]+ '(' args ')'[':' '(' args ')'] stat
			</em></span></pre><p>
				creates a new function.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e867"></a>Class declaration</h3></div></div><div></div></div><a class="indexterm" name="d0e868"></a><pre class="programlisting"><span class="emphasis"><em>
memberdecl := id '=' exp [';'] |	'[' exp ']' '=' exp [';'] |	functionstat | 'constructor' functionexp
stat:= 'class' derefexp ['extends' derefexp] '{'
			[memberdecl]
		'}'
			</em></span></pre><p>
				creates a new class.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e879"></a>try/catch</h3></div></div><div></div></div><a class="indexterm" name="d0e880"></a><pre class="programlisting"><span class="emphasis"><em>stat:= 'try' stat 'catch' '(' id ')' stat</em></span></pre><p>
				The try statement encloses a block of code in which an exceptional condition can occur,
				such as a runtime error or a throw statement. The catch clause provides the exceptionhandling
				code. When a catch clause catches an exception, its id is bound to that
				exception.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e891"></a>throw</h3></div></div><div></div></div><a class="indexterm" name="d0e892"></a><pre class="programlisting"><span class="emphasis"><em>stat:= 'throw' exp</em></span></pre><p>
				Throws an exception. Any value can be thrown.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e903"></a>const</h3></div></div><div></div></div><a class="indexterm" name="d0e904"></a><pre class="programlisting"><span class="emphasis"><em>stat:= 'const' id '=' 'Integer | Float | StringLiteral</em></span>
      </pre><p>
        Declares a constant (see <a href="#constants">Constants &amp; Enumerations</a>).
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e919"></a>enum</h3></div></div><div></div></div><a class="indexterm" name="d0e920"></a><pre class="programlisting">
        <span class="emphasis"><em>
          enumerations := ( &#8216;id&#8217; '=' Integer | Float | StringLiteral ) [&#8216;,&#8217;]
          stat:= 'enum' id '{' enumerations '}'
        </em></span>
      </pre><p>
        Declares an enumeration (see <a href="#constants">Constants &amp; Enumerations</a>).
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e936"></a>expression statement</h3></div></div><div></div></div><a class="indexterm" name="d0e937"></a><pre class="programlisting"><span class="emphasis"><em>stat := exp</em></span></pre><p>
				In Pscript every expression is also allowed as statement, if so, the result of the
				expression is thrown away.
			</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e948"></a>Expressions</h2></div></div><div></div></div><a class="indexterm" name="d0e949"></a><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e955"></a>Assignment(<tt class="literal">=</tt>) &amp; new slot(<tt class="literal">&lt;-</tt>)</h3></div></div><div></div></div><a class="indexterm" name="d0e956"></a><a class="indexterm" name="d0e959"></a><pre class="programlisting"><span class="emphasis"><em>
exp := derefexp '=' exp
exp:= derefexp '&lt;-' exp
			</em></span></pre><p>
				pscript implements 2 kind of assignment: the normal assignment(=)
			</p><pre class="programlisting">a=10;</pre><p>and the "new slot" assignment.</p><pre class="programlisting">a &lt;- 10;</pre><p>	
				The new slot expression allows to add a new slot into a table(see <a href="#tables">Tables</a>). If the slot
				already exists in the table it behaves like a normal assignment.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e987"></a>Operators</h3></div></div><div></div></div><a class="indexterm" name="d0e988"></a><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e994"></a>?: Operator</h4></div></div><div></div></div><a class="indexterm" name="d0e995"></a><pre class="programlisting"><span class="emphasis"><em>exp := exp_cond '?' exp1 ':' exp2</em></span></pre><p>conditionally evaluate an expression depending on the result of an expression.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1006"></a>Arithmetic</h4></div></div><div></div></div><a class="indexterm" name="d0e1007"></a><pre class="programlisting"><span class="emphasis"><em>exp:= 'exp' op 'exp'</em></span></pre><p>
					Pscript supports the standard arithmetic operators +, -, *, / and %.
					Other than that is also supports compact operators (+=,-=,*=,/=,%=) and
					increment and decrement operators(++ and --);
				</p><pre class="programlisting">
a+=2;
//is the same as writing
a=a+2;
x++
//is the same as writing
x=x+1
				</pre><p>
					All operators work normally with integers and floats; if one operand is an integer and one
					is a float the result of the expression will be float.
					The + operator has a special behavior with strings; if one of the operands is a string the
					operator + will try to convert the other operand to string as well and concatenate both
					together. For instances and tables, _tostring is invoked.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1022"></a>Relational</h4></div></div><div></div></div><a class="indexterm" name="d0e1023"></a><pre class="programlisting"><span class="emphasis"><em>exp:= 'exp' op 'exp'</em></span></pre><p>Relational operators in Pscript are : == &lt; &lt;= &gt; &gt;= !=</p><p>
					These operators return true if the expression is false and a value different than true if the
					expression is true. Internally the VM uses the integer 1 as true but this could change in
					the future.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1036"></a>3 ways compare</h4></div></div><div></div></div><a class="indexterm" name="d0e1037"></a><pre class="programlisting"><span class="emphasis"><em>exp:= 'exp' op 'exp'</em></span></pre><p>
          the 3 ways compare operator &lt;=&gt; compares 2 values A and B and returns an integer less than 0
          if A &lt; B, 0 if A == B and an integer greater than 0 if A &gt; B.
        </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1048"></a>Logical</h4></div></div><div></div></div><a class="indexterm" name="d0e1049"></a><pre class="programlisting"><span class="emphasis"><em>
exp := exp op exp
exp := '!' exp
				</em></span></pre><p>Logical operators in Pscript are : &amp;&amp; || !</p><p>
					The operator &amp;&amp; (logical and) returns null if its first argument is null, otherwise returns
					its second argument.		
					The operator || (logical or) returns its first argument if is different than null, otherwise
					returns the second argument.
				</p><p>
					The '!' operator will return null if the given value to negate was different than null, or a
					value different than null if the given value was null.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1064"></a>in operator</h4></div></div><div></div></div><a class="indexterm" name="d0e1065"></a><pre class="programlisting"><span class="emphasis"><em>exp:= keyexp 'in' tableexp</em></span></pre><p>
					Tests the existence of a slot in a table.
					Returns true if keyexp is a valid key in tableexp
				</p><pre class="programlisting">

local t=
{
    foo="I'm foo",
    [123]="I'm not foo"
}

if("foo" in t) dostuff("yep");
if(123 in t) dostuff();
				</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1078"></a>instanceof operator</h4></div></div><div></div></div><a class="indexterm" name="d0e1079"></a><pre class="programlisting"><span class="emphasis"><em>exp:= instanceexp 'instanceof' classexp</em></span></pre><p>
					Tests if a class instance is an instance of a certain class.
					Returns true if instanceexp is an instance of classexp.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1090"></a>typeof operator</h4></div></div><div></div></div><a class="indexterm" name="d0e1091"></a><pre class="programlisting"><span class="emphasis"><em>exp:= 'typeof' exp</em></span></pre><p>returns the type name of a value as string.</p><pre class="programlisting">
local a={},b="pscript"
print(typeof a); //will print "table"
print(typeof b); //will print "string"		
				</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1104"></a>comma operator</h4></div></div><div></div></div><a class="indexterm" name="d0e1105"></a><pre class="programlisting"><span class="emphasis"><em>exp:= exp ',' exp</em></span></pre><p>
					The comma operator evaluates two expression left to right, the result of the operator is
					the result of the expression on the right; the result of the left expression is discarded.
				</p><pre class="programlisting">
local j=0,k=0;
for(local i=0; i&lt;10; i++ , j++)
{
	k = i + j;
}
local a,k;
a = (k=1,k+2); //a becomes 3		
				</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1118"></a>Bitwise Operators</h4></div></div><div></div></div><a class="indexterm" name="d0e1119"></a><pre class="programlisting"><span class="emphasis"><em>
exp:= 'exp' op 'exp'
exp := '~' exp
				</em></span></pre><p>
					Pscript supports the standard c-like bit wise operators &amp;,|,^,~,&lt;&lt;,&gt;&gt; plus the unsigned 
					right shift operator &gt;&gt;&gt;. The unsigned right shift works exactly like the normal right shift operator(&gt;&gt;)
					except for treating the left operand as an unsigned integer, so is not affected by the sign. Those operators
					only work on integers values, passing of any other operand type to these operators will
					cause an exception.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1130"></a>Operators precedence</h4></div></div><div></div></div><a class="indexterm" name="d0e1131"></a><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td><tt class="literal">-,~,!,typeof ,++,--</tt></td><td>highest</td></tr><tr><td><tt class="literal">/, *, %</tt></td><td>...</td></tr><tr><td><tt class="literal">+, -</tt></td><td>&nbsp;</td></tr><tr><td><tt class="literal">&lt;&lt;, &gt;&gt;,&gt;&gt;&gt;</tt></td><td>&nbsp;</td></tr><tr><td><tt class="literal">&lt;, &lt;=, &gt;, &gt;=</tt></td><td>&nbsp;</td></tr><tr><td><tt class="literal">==, !=, &lt;=&gt;</tt></td><td>&nbsp;</td></tr><tr><td><tt class="literal">&amp;</tt></td><td>&nbsp;</td></tr><tr><td><tt class="literal">^</tt></td><td>&nbsp;</td></tr><tr><td><tt class="literal">|</tt></td><td>&nbsp;</td></tr><tr><td><tt class="literal">&amp;&amp;, in</tt></td><td>&nbsp;</td></tr><tr><td><tt class="literal">||</tt></td><td>&nbsp;</td></tr><tr><td><tt class="literal">?:</tt></td><td>&nbsp;</td></tr><tr><td><tt class="literal">+=,=,-=</tt></td><td>...</td></tr><tr><td><tt class="literal">,(comma operator)</tt></td><td>lowest</td></tr></tbody></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1216"></a>Table constructor</h3></div></div><div></div></div><a class="indexterm" name="d0e1217"></a><a name="tableconstructor"></a><pre class="programlisting"><span class="emphasis"><em>
tslots := ( &#8216;id&#8217; &#8216;=&#8217; exp | &#8216;[&#8216; exp &#8216;]&#8217; &#8216;=&#8217; exp ) [&#8216;,&#8217;]
exp := &#8216;{&#8217; [tslots] &#8216;}&#8217;
			</em></span></pre><p>Creates a new table.</p><pre class="programlisting">
local a={} //create an empty table				
			</pre><p>A table constructor can also contain slots declaration; With the syntax:</p><pre class="programlisting"><span class="emphasis"><em>id = exp [',']</em></span></pre><p>a new slot with id as key and exp as value is created</p><pre class="programlisting">
local a=
{
    slot1="I'm the slot value"
}
			</pre><p>An alternative syntax can be</p><pre class="programlisting"><span class="emphasis"><em>'[' exp1 ']' = exp2 [',']</em></span></pre><p>A new slot with exp1 as key and exp2 as value is created</p><pre class="programlisting">
local a=
{
    [1]="I'm the value"
}
			</pre><p>both syntaxes can be mixed</p><pre class="programlisting">
local table=
{
    a=10,
    b="string",
    [10]={},
    function bau(a,b)
    {
        return a+b;
    }
}
			</pre><p>The comma between slots is optional.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1254"></a>Table with JSON syntax</h4></div></div><div></div></div><a class="indexterm" name="d0e1255"></a><a name="jsonsyntax"></a><p>Since Pscript 3.0 is possible to declare a table using JSON syntax(see http://www.wikipedia.org/wiki/JSON).</p><p>the following JSON snippet:</p><pre class="programlisting">
local x = {
  "id": 1,
  "name": "Foo",
  "price": 123,
  "tags": ["Bar","Eek"]
}
        </pre><p>is equivalent to the following pscript code:</p><pre class="programlisting">
local x = {
  id = 1,
  name = "Foo",
  price = 123,
  tags = ["Bar","Eek"]
}
       </pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1274"></a>clone</h3></div></div><div></div></div><a class="indexterm" name="d0e1275"></a><pre class="programlisting"><span class="emphasis"><em>exp:= &#8216;clone&#8217; exp</em></span></pre><p>
				Clone performs shallow copy of a table, array or class instance (copies all slots in the new object without
				recursion). If the source table has a delegate, the same delegate will be assigned as
				delegate (not copied) to the new table (see <a href="#delegation">Delegation</a>).
			</p><p>After the new object is ready the &#8220;_cloned&#8221; meta method is called (see <a href="#metamethods">Metamethods</a>).</p><p>When a class instance is cloned the constructor is not invoked(initializations must rely on <tt class="literal">_cloned</tt> instead</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1299"></a>Array constructor</h3></div></div><div></div></div><a class="indexterm" name="d0e1300"></a><pre class="programlisting"><span class="emphasis"><em>exp := &#8216;[&#8217; [explist] &#8216;]&#8217;</em></span></pre><p>Creates a new array.</p><pre class="programlisting">
a &lt;- [] //creates an empty array
			</pre><p>arrays can be initialized with values during the construction</p><pre class="programlisting">
a &lt;- [1,"string!",[],{}] //creates an array with 4 elements
			</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1317"></a>Tables</h2></div></div><div></div></div><a class="indexterm" name="d0e1318"></a><a name="tables"></a><p>
			Tables are associative containers implemented as pairs of key/value (called slot); values
			can be any possible type and keys any type except 'null'.
			Tables are pscript's skeleton, delegation and many other features are all implemented
			through this type; even the environment, where global variables are stored, is a table
			(known as root table).
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1327"></a>Construction</h3></div></div><div></div></div><p>Tables are created through the table constructor (see <a href="#tableconstructor">Table constructor</a>)</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1336"></a>Slot creation</h3></div></div><div></div></div><a class="indexterm" name="d0e1337"></a><p>
				Adding a new slot in a existing table is done through the "new slot" operator '&lt;-'; this
				operator behaves like a normal assignment except that if the slot does not exists it will
				be created.
			</p><pre class="programlisting">
local a={}
			</pre><p>
				The following line will cause an exception because the slot named 'newslot' does not exist
				in the table &#8216;a&#8217;
			</p><pre class="programlisting">
a.newslot = 1234
			</pre><p>this will succeed:</p><pre class="programlisting">
a.newslot &lt;- 1234;
			</pre><p>or</p><pre class="programlisting">
a[1] &lt;- "I'm the value of the new slot";
			</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1361"></a>Slot deletion</h3></div></div><div></div></div><a class="indexterm" name="d0e1362"></a><pre class="programlisting"><span class="emphasis"><em>exp:= delete derefexp</em></span></pre><p>
				Deletion of a slot is done through the keyword delete; the result of this expression will be
				the value of the deleted slot.
			</p><pre class="programlisting">
a &lt;- {
    test1=1234
    deleteme="now"
}

delete a.test1
print(delete a.deleteme); //this will print the string "now"
			</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1377"></a>Arrays</h2></div></div><div></div></div><a class="indexterm" name="d0e1378"></a><p>
			An array is a sequence of values indexed by a integer number from 0 to the size of the
			array minus 1. Arrays elements can be obtained through their index.
		</p><pre class="programlisting">
local a=[&#8220;I&#8217;m a string&#8221;, 123]
print(typeof a[0]) //prints "string"
print(typeof a[1]) //prints "integer"			
		</pre><p>
			Resizing, insertion, deletion of arrays and arrays elements is done through a set of
			standard functions (see <a href="#builtin">built-in functions</a>).
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1393"></a>Functions</h2></div></div><div></div></div><a class="indexterm" name="d0e1394"></a><a name="functions"></a><p>
			Functions are first class values like integer or strings and can be stored in table slots,
			local variables, arrays and passed as function parameters.
			Functions can be implemented in Pscript or in a native language with calling conventions
			compatible with ANSI C.
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1403"></a>Function declaration</h3></div></div><div></div></div><a class="indexterm" name="d0e1404"></a><p>Functions are declared through the function expression</p><pre class="programlisting">
local a= function(a,b,c) {return a+b-c;}		
			</pre><p>or with the syntactic sugar</p><pre class="programlisting">
function ciao(a,b,c)
{
    return a+b-c;
}		
			</pre><p>that is equivalent to</p><pre class="programlisting">
this.ciao &lt;- function(a,b,c)
{
    return a+b-c;
}
			</pre><p>a local function can be declared with this syntactic sugar</p><pre class="programlisting">
        
local function tuna(a,b,c)
{
    return a+b-c;
}
			
      </pre><p>that is equivalent to</p><pre class="programlisting">
        
local tuna = function(a,b,c)
{
    return a+b-c;
}
			
      </pre><p>is also possible to declare something like</p><pre class="programlisting">
T &lt;- {}
function T::ciao(a,b,c)
{
    return a+b-c;
}

//that is equivalent to write

T.ciao &lt;- function(a,b,c)
{
    return a+b-c;
}

//or

T &lt;- {
	function ciao(a,b,c)
	{
		return a+b-c;
	}
}
			</pre><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1435"></a>Default Paramaters</h4></div></div><div></div></div>
        Pscript's functions can have default parameters.
        <p>A function with default parameters is declared as follows:</p><pre class="programlisting">
        
function test(a,b,c = 10, d = 20)
{
	....
}
        
        </pre><p>
          when the function <tt class="literal">test</tt> is invoked and the parameter c or d are not specified, 
          the VM autometically assigns the default value to the unspecified parameter. A default parameter can be
          any valid pscript expression. The expression is evaluated at runtime.
        </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1448"></a>Function with variable number of paramaters</h4></div></div><div></div></div>
        Pscript's functions can have variable number of parameters(varargs functions).
        <p>
				  A vararg function is declared by adding three dots (`...&acute;) at the end of its parameter list.
			  </p><p>
				  When the function is called all the extra parameters will be accessible through the <span class="emphasis"><em>array</em></span>
				  called <tt class="literal">vargv</tt>, that is passed as implicit parameter.
			  </p><p>
				  <tt class="literal">vargv</tt> is a regular pscript array and can be used accordingly. 
			  </p><pre class="programlisting">
      
function test(a,b,...)
{
	for(local i = 0; i&lt; vargv.len(); i++)
	{
		::print("varparam "+i+" = "+vargv[i]+"\n");
	}
  foreach(i,val in vargv)
	{
		::print("varparam "+i+" = "+val+"\n");
	}
}

test("goes in a","goes in b",0,1,2,3,4,5,6,7,8);
			  </pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1470"></a>Function calls</h3></div></div><div></div></div><a class="indexterm" name="d0e1471"></a><pre class="programlisting"><span class="emphasis"><em>exp:= derefexp &#8216;(&#8216; explist &#8216;)&#8217;</em></span></pre><p>
				The expression is evaluated in this order: derefexp after the explist (arguments) and at
				the end the call.
			</p><p>
				Every function call in Pscript passes the environment object &#8216;this&#8217; as hidden parameter
				to the called function. The &#8216;this&#8217; parameter is the object where the function was indexed
				from.
			</p><p>
				If we call a function with this syntax
			</p><pre class="programlisting">
table.foo(a)
			</pre><p>the environment object passed to foo will be &#8216;table&#8217;</p><pre class="programlisting">
foo(x,y) // equivalent to this.foo(x,y)
			</pre><p>The environment object will be &#8216;this&#8217; (the same of the caller function).</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1496"></a>Binding an environment to a function</h3></div></div><div></div></div><a class="indexterm" name="d0e1497"></a><p>
        while by default a pscript function call passes as environment object 'this', the object
        where the function was indexed from. However, is also possible to statically bind an evironment to a
        closure using the built-in method <tt class="literal">closure.bindenv(env_obj)</tt>.
        The method bindenv() returns a new instance of a closure with the environment bound to it.
        When an environment object is bound to a function, every time the function is invoked, its
        'this' parameter will always be the previously bound environent.
        This mechanism is useful to implement callbacks systems similar to C# delegates.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
          The closure keeps a weak reference to the bound environmet object, because of this if
          the object is deleted, the next call to the closure will result in a <tt class="literal">null</tt>
          environment object.
        </div><p>
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1514"></a>Lambda expressions</h3></div></div><div></div></div><a class="indexterm" name="d0e1515"></a><p>
        <span class="emphasis"><em>exp := '@' '(' paramlist ')' exp</em></span>
        </p><p>
          Lambda expressions are a synctactic sugar to quickly define a function that consists of a single expression.
          This feature comes handy when functional programming patterns are applied, like map/reduce or passing a compare method to
          array.sort().
        </p><p>
        </p><p>here a lambda expression</p><p>
</p><pre class="programlisting">
        local myexp = @(a,b) a + b
</pre><p>
        </p><p>that is equivalent to</p><p>
</p><pre class="programlisting">
        local myexp = function(a,b) { return a + b; }
</pre><p>
        </p><p>a more useful usage could be</p><p>
</p><pre class="programlisting">
        local arr = [2,3,5,8,3,5,1,2,6];
        arr.sort(@(a,b) a &lt;=&gt; b);
        arr.sort(@(a,b) -(a &lt;=&gt; b));
</pre><p>
        </p><p>that could have been written as</p><p>
</p><pre class="programlisting">
        local arr = [2,3,5,8,3,5,1,2,6];
        arr.sort(function(a,b) { return a &lt;=&gt; b; } );
        arr.sort(function(a,b) { return -(a &lt;=&gt; b); } );
</pre><p>
        </p><p>other than being limited to a single expression lambdas support all features of regular functions.
        in fact are implemented as a compile time feature.</p><p>
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1556"></a>Free variables</h3></div></div><div></div></div><a class="indexterm" name="d0e1557"></a><p>
        A free variable is a variable external from the function scope as is not a local variable
        or parameter of the function.
        Free variables reference a local variable from a outer scope.
        In the following example the variables 'testy', 'x' and 'y' are bound to the function 'foo'.
      </p><pre class="programlisting">
local x=10,y=20
local testy=&#8220;I&#8217;m testy&#8221;

function foo(a,b)
{
    ::print(testy);
    return a+b+x+y;
}
			</pre><p>
        A program can read or write a free variable.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1569"></a>Tail recursion</h3></div></div><div></div></div><a class="indexterm" name="d0e1570"></a><p>
				Tail recursion is a method for partially transforming a recursion in a program into an
				iteration: it applies when the recursive calls in a function are the last executed
				statements in that function (just before the return).
				If this happenes the pscript interpreter collapses the caller stack frame before the
				recursive call; because of that very deep recursions are possible without risk of a stack
				overflow.
			</p><pre class="programlisting">
function loopy(n)
{
    if(n&gt;0){
        ::print(&#8220;n=&#8221;+n+&#8221;\n&#8221;);
        return loopy(n-1);
    }
}

loopy(1000);
			</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1580"></a>Classes</h2></div></div><div></div></div><a class="indexterm" name="d0e1581"></a><a name="classes"></a><p>
		Pscript implements a class mechanism similar to languages like Java/C++/etc... 
		however because of its dynamic nature it differs in several aspects.
		Classes are first class objects like integer or strings and can be stored in 
		table slots local variables, arrays and passed as function parameters.
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1590"></a>Class declaration</h3></div></div><div></div></div><a class="indexterm" name="d0e1591"></a><p>
			A class object is created through the keyword 'class' . The class object follows
			the same declaration syntax of a table(see tables) with the only difference
			of using ';' as optional separator rather than ','.
			</p><p>
		For instance:
</p><pre class="programlisting">
class Foo {
	//constructor
	constructor(a)
	{
		testy = ["stuff",1,2,3,a];
	}
	//member function
	function PrintTesty()
	{
		foreach(i,val in testy)
		{
			::print("idx = "+i+" = "+val+" \n");
		}
	}
	//property
	testy = null;
	
}
</pre><p>
the previous code examples is a syntactic sugar for:
</p><pre class="programlisting">
Foo &lt;- class {
	//constructor
	constructor(a)
	{
		testy = ["stuff",1,2,3,a];
	}
	//member function
	function PrintTesty()
	{
		foreach(i,val in testy)
		{
			::print("idx = "+i+" = "+val+" \n");
		}
	}
	//property
	testy = null;
	
}
</pre><p>

in order to emulate namespaces, is also possible to declare something like this
</p><pre class="programlisting">
//just 2 regular nested tables
FakeNamespace &lt;- {
	Utils = {}
}

class FakeNamespace.Utils.SuperClass {
	constructor()
	{
		::print("FakeNamespace.Utils.SuperClass")
	}
	function DoSomething()
	{
		::print("DoSomething()")
	}
}

function FakeNamespace::Utils::SuperClass::DoSomethingElse()
{
	::print("FakeNamespace::Utils::SuperClass::DoSomethingElse()")
}

local testy = FakeNamespace.Utils.SuperClass();
testy.DoSomething();
testy.DoSomethingElse();
</pre><p>
		After its declaration, methods or properties can be added or modified by following
		the same rules that apply to a table(operator <tt class="literal">&lt;-</tt> and <tt class="literal">=</tt>).
</p><pre class="programlisting">
//adds a new property
Foo.stuff &lt;- 10;

//modifies the default value of an existing property
Foo.testy = "I'm a string";

//adds a new method
function Foo::DoSomething(a,b)
{
	return a+b;
}
</pre><p>
		After a class is instantiated is no longer possible to add new properties however is possible to add or replace methods.
		</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1618"></a>Static variables</h4></div></div><div></div></div><a class="indexterm" name="d0e1619"></a>
				Pscript's classes support static member variables. A static variable shares its value
				between all instances of the class. Statics are declared by prefixing the variable declaration
				with the keyword <tt class="literal">static</tt>; the declaration must be in the class body.
				<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>Statics are read-only.</div><pre class="programlisting">
class Foo {
	constructor()
	{
		//..stuff
	}
	name = "normal variable";
	//static variable
	static classname = "The class name is foo";
};
</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1632"></a>Class attributes</h4></div></div><div></div></div><a class="indexterm" name="d0e1633"></a>
				Classes allow to associate attributes to it's members. Attributes are a form of metadata
				that can be used to store application specific informations, like documentations
				strings, properties for IDEs, code generators etc...
				Class attributes are declared in the class body by preceding the member declaration and
				are delimited by the symbol <tt class="literal">&lt;/</tt> and <tt class="literal">/&gt;</tt>.
				Here an example:
<pre class="programlisting">
class Foo &lt;/ test = "I'm a class level attribute" /&gt;{
	&lt;/ test = "freakin attribute" /&gt; //attributes of PrintTesty
	function PrintTesty()
	{
		foreach(i,val in testy)
		{
			::print("idx = "+i+" = "+val+" \n");
		}
	}
	&lt;/ flippy = 10 , second = [1,2,3] /&gt; //attributes of testy
	testy = null;
	
}
</pre>
			Attributes are, matter of fact, a table. Pscript uses <tt class="literal">&lt;/ /&gt;</tt> syntax
			instead of curly brackets <tt class="literal">{}</tt> for the attribute declaration to increase readability.
			<p>
			This means that all rules that apply to tables apply to attributes.
			</p><p>
			Attributes can be retrieved through the built-in function <tt class="literal">classobj.getattributes(membername)</tt> (see <a href="#builtin">built-in functions</a>).
			and can be modified/added through the built-in function <tt class="literal">classobj.setattributes(membername,val)</tt>.
			</p><p>
			the following code iterates through the attributes of all Foo members.
</p><pre class="programlisting">
foreach(member,val in Foo)
{
	::print(member+"\n");
	local attr;
	if((attr = Foo.getattributes(member)) != null) {
		foreach(i,v in attr)
		{
			::print("\t"+i+" = "+(typeof v)+"\n");
		}
	}
	else {
		::print("\t&lt;no attributes&gt;\n")
	}
}
</pre><p>
			</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1672"></a>Class instances</h3></div></div><div></div></div><a class="indexterm" name="d0e1673"></a><p>
			The class objects inherits several of the table's feature with the difference that multiple instances of the
			same class can be created.
			A class instance is an object that share the same structure of the table that created it but
			holds is own values.
			Class <span class="emphasis"><em>instantiation</em></span> uses function notation.
			A class instance is created by calling a class object. Can be useful to imagine a class like a function
			that returns a class instance.
			
</p><pre class="programlisting">
//creates a new instance of Foo
local inst = Foo(); 
</pre><p>
			When a class instance is created its member are initialized <span class="emphasis"><em>with the same value</em></span> specified in the
			class declaration. The values are copied verbatim, <span class="emphasis"><em>no cloning is performed</em></span> even if the value is a container or a class instances.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
        FOR C# and Java programmers:
        <p>
          Pscript doesn't clone member's default values nor executes the member declaration for each instace(as C# or java).
          So consider this example:
          </p><pre class="programlisting">
class Foo {
  myarray = [1,2,3]
  mytable = {}
}

local a = Foo();
local b = Foo();
</pre><p>
          In the snippet above both instances will refer to the same array and same table.To archieve what a C# or Java programmer would
          exepect, the following approach should be taken.
</p><pre class="programlisting">
class Foo {
  myarray = null
  mytable = null
  constructor()
  {
    myarray = [1,2,3]
    mytable = {}
  }
}

local a = Foo();
local b = Foo();
<p></p>
</pre><p>
         
        </p></div><p>
			</p><p>
			When a class defines a method called 'constructor', the class instantiation operation will
			automatically invoke it for the newly created instance.
			The constructor method can have parameters, this will impact on the number of parameters
			that the <span class="emphasis"><em>instantiation operation</em></span> will require.
			Constructors, as normal functions, can have variable number of parameters (using the parameter <tt class="literal">...</tt>).
			</p><p>
</p><pre class="programlisting">
class Rect {
	constructor(w,h)
	{
		width = w;
		height = h;		
	}
	x = 0;
	y = 0;
	width = null;
	height = null;
}

//Rect's constructor has 2 parameters so the class has to be 'called'
//with 2 parameters
local rc = Rect(100,100);
 
</pre><p>
						
			After an instance is created, its properties can be set or fetched following the
			same rules that apply to tables. Methods cannot be set.
			</p><p>
				Instance members cannot be removed.
			</p><p>
			</p><p>
				The class object that created a certain instance can be retrieved through the built-in function
				<tt class="literal">instance.getclass()</tt>(see <a href="#builtin">built-in functions</a>)
			</p><p>
			The operator <tt class="literal">instanceof</tt> tests if a class instance is an instance of a certain class.
</p><pre class="programlisting">
local rc = Rect(100,100);
if(rc instanceof ::Rect) {
	::print("It's a rect");
}
else {
	::print("It isn't a rect");
}
			</pre><p>
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>Since Pscript 3.x instanceof doesn't throw an exception if the left expression is not a class, it simply fails</div><p>
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1738"></a>Inheritance</h3></div></div><div></div></div><a class="indexterm" name="d0e1739"></a><p>
			Pscript's classes support single inheritance by adding the keyword <tt class="literal">extends</tt>, followed
			by an expression, in the class declaration.
			The syntax for a derived class is the following:
			</p><pre class="programlisting">
class SuperFoo extends Foo {
	function DoSomething() {
		::print("I'm doing something");
	}
}
			</pre><p>
			When a derived class is declared, Pscript first copies all base's members in the
			new class then proceeds with evaluating the rest of the declaration.
			</p><p>
			</p><p>
			A derived class inherit all members and properties of it's base, if the derived class
			overrides a base function the base implementation is shadowed.
			It's possible to access a overridden method of the base class by fetching the method from
			through the 'base' keyword.
			</p><p>
			Here an example:
</p><pre class="programlisting">
class Foo {
	function DoSomething() {
		::print("I'm the base");
	}
};

class SuperFoo extends Foo {
	//overridden method
	function DoSomething() {
		//calls the base method
		base.DoSomething();
		::print("I'm doing something");
	}
}
			</pre><p>
Same rule apply to the constructor. The constructor is a regular function (apart from being automatically invoked on contruction).
</p><pre class="programlisting">
  
class BaseClass {
	constructor()
	{
		::print("Base constructor\n");
	}
}

class ChildClass extends BaseClass {
	constructor()
	{
		base.constructor();
		::print("Child constructor\n");
	}
}

local test = ChildClass();
</pre><p>
			</p><p>
			The base class of a derived class can be retrieved through the built-in method <tt class="literal">getbase()</tt>.
			
			</p><pre class="programlisting">
local thebaseclass = SuperFoo.getbase();
			</pre><p>
			</p>
			Note that because methods do not have special protection policies when calling methods of the same
			objects, a method of a base class that calls a method of the same class can end up calling a overridden method of the derived class.
      <p>
        A method of a base class can be explicitly invoked by a method of a derived class though the keyword <tt class="literal">base</tt>(as in base.MyMethod() ).
      </p></div><pre class="programlisting">
class Foo {
	function DoSomething() {
		::print("I'm the base");
	}
	function DoIt()
	{
		DoSomething();
	}
};

class SuperFoo extends Foo {
	//overridden method
	function DoSomething() {
		::print("I'm the derived");
		
	}
	function DoIt() {
		base.DoIt();
	}
}

//creates a new instance of SuperFoo
local inst = SuperFoo(); 

//prints "I'm the derived"
inst.DoIt();


			</pre><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1779"></a>Metamethods</h3></div></div><div></div></div><a class="indexterm" name="d0e1780"></a><p>
				Class instances allow the customization of certain aspects of the
				their semantics through	metamethods(see <a href="#metamethods">Metamethods</a>).
				For C++ programmers: "metamethods behave roughly like overloaded operators".
				The metamethods supported by classes are <tt class="literal">_add, _sub, _mul, _div, _unm, _modulo,
				_set, _get, _typeof, _nexti, _cmp, _call, _delslot,_tostring</tt>
				</p><p>
        </p><p>
        Class objects instead support only 2 metamethods : <tt class="literal">_newmember and _inherited</tt>    
        </p><p>
the following example show how to create a class that implements the metamethod <tt class="literal">_add</tt>.
</p><pre class="programlisting">
class Vector3 {
	constructor(...)
	{
		if(vargv.len() &gt;= 3) {
			x = vargv[0];
			y = vargv[1];
			z = vargv[2];
		}
	}
	function _add(other)
	{
		return ::Vector3(x+other.x,y+other.y,z+other.z);
	}
	
	x = 0;
	y = 0;
	z = 0;
}

local v0 = Vector3(1,2,3)
local v1 = Vector3(11,12,13)
local v2 = v0 + v1;
::print(v2.x+","+v2.y+","+v2.z+"\n");
</pre><p>
			</p><p>
        </p><p>
          Since version 2.1, classes support 2 metamethods <tt class="literal">_inherited</tt> and <tt class="literal">_newmember</tt>. 
          <tt class="literal">_inherited</tt> is invoked when a class inherits from the one that implements <tt class="literal">_inherited</tt>.
          <tt class="literal">_newmember</tt> is invoked for each member that is added to the class(at declaration time).
        </p><p>
			</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1827"></a>Generators</h2></div></div><div></div></div><a class="indexterm" name="d0e1828"></a><a name="generators"></a><p>
			A function that contains a yield statement is called &#8216;generator function&#8217;.
			When a generator function is called, it does not execute the function body, instead it
			returns a new suspended generator.
			The returned generator can be resumed through the resume statement while it is alive.
			The yield keyword, suspends the execution of a generator and optionally returns the
			result of an expression to the function that resumed the generator.
			The generator dies when it returns, this can happen through an explicit return
			statement or by exiting the function body; If an unhandled exception (or runtime error)
			occurs while a generator is running, the generator will automatically die. A dead
			generator cannot be resumed anymore.
		</p><pre class="programlisting">
function geny(n)
{
    for(local i=0;i&lt;n;i+=1)
        yield i;
    return null;
}

local gtor=geny(10);
local x;
while(x=resume gtor) print(x+&#8221;\n&#8221;);
		</pre><p>the output of this program will be</p><pre class="programlisting">
0
1
2
3
4
5
6
7
8
9
		</pre>
    generators can also be iterated using the foreach statement. When a generator is evaluated
    by <tt class="literal">foreach</tt>, the generator will be resumed for each iteration until it returns. The value
    returned by the <tt class="literal">return</tt> statement will be ignored.
    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>A suspended generator will hold a strong reference to all the values stored in it's local variables except the <tt class="literal">this</tt>
     object that is only a weak reference. A running generator hold a strong reference also to the <tt class="literal">this</tt> object.
  </div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1858"></a>Constants &amp; Enumerations</h2></div></div><div></div></div><a class="indexterm" name="d0e1859"></a><a name="constants"></a><p>
      Pscript allows to bind constant values to an identifier that will be evaluated compile-time.
      This is archieved though constants and enumarations.
    </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1869"></a>Constants</h3></div></div><div></div></div><p>
        </p><p>
          Constants bind a specific value to an indentifier. Constants are similar to
          global values, except that they are evaluated compile time and their value cannot be changed.
        </p><p>
        </p><p>
          constants values can only be integers, floats or string literals. No expression are allowed.
          are declared with the following syntax.
        </p><p>
        </p><pre class="programlisting">
          
const foobar = 100;
const floatbar = 1.2;
const stringbar = "I'm a contant string";
          
        </pre><p>
        </p><p>
          constants are always globally scoped, from the moment they are declared, any following code
          can reference them.
          Constants will shadow any global slot with the same name( the global slot will remain visible by using the <tt class="literal">::</tt> syntax).
        </p><p>
        </p><pre class="programlisting">
         
local x = foobar * 2;
        
        </pre><p>
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1892"></a>Enumerations</h3></div></div><div></div></div><p>
        </p><p>
          As Constants, Enumerations bind a specific value to a name. Enumerations are also evaluated compile time 
          and their value cannot be changed.
        </p><p>
        </p><p>
          An enum declaration introduces a new enumeration into the program.
          Enumerations values can only be integers, floats or string literals. No expression are allowed.
        </p><p>
        </p><p>
        </p><pre class="programlisting">
        
enum Stuff {
  first, //this will be 0
  second, //this will be 1
  third //this will be 2
}
        
        </pre><p>
        
            or
        
 </p><pre class="programlisting">

enum Stuff {
  first = 10
  second = "string"
  third = 1.2
}

 </pre><p>
        </p><p>
        </p><p>
          An enum value is accessed in a manner that's similar to accessing a static class member.
          The name of the member must be qualified with the name of the enumeration, for example <tt class="literal">Stuff.second</tt>.
          Enumerations will shadow any global slot with the same name( the global slot will remain visible by using the <tt class="literal">::</tt> syntax).
        </p><p>
        </p><pre class="programlisting">
          
local x = Stuff.first * 2;

        </pre><p>
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1924"></a>Implementation notes</h3></div></div><div></div></div><p>
        Enumerations and Contants are a compile-time feature. Only integers, string and floats can be declared as const/enum;
        No expressions are allowed(because they would have to be evaluated compile time).
        When a const or an enum is declared, it is added compile time to the <tt class="literal">consttable</tt>. This table is stored in the VM shared state
        and is shared by the VM and all its threads.
        The <tt class="literal">consttable</tt> is a regular pscript table; In the same way as the <tt class="literal">roottable</tt>
        it can be modified runtime.
        You can access the <tt class="literal">consttable</tt> through the built-in function <tt class="literal">getconsttable()</tt>
        and also change it through the built-in function <tt class="literal">setconsttable()</tt>
        </p><p>
        here some example:
        </p><pre class="programlisting">
          
//create a constant
getconsttable()["something"] &lt;- 10"
//create an enumeration
getconsttable()["somethingelse"] &lt;- { a = "10", c = "20", d = "200"};
//deletes the constant
delete getconsttable()["something"]
//deletes the enumeration
delete getconsttable()["somethingelse"]
        
        </pre><p>
          This system allows to procedurally declare constants and enumerations, it is also possible to assign any pscript type
          to a constant/enumeration(function,classes etc...). However this will make serialization of a code chunk impossible.
        </p><p>
        
      </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1954"></a>Threads</h2></div></div><div></div></div><a class="indexterm" name="d0e1955"></a><a name="threads"></a><p>
		Pscript supports cooperative threads(also known as coroutines).
		A cooperative thread is a subroutine that can suspended in mid-execution and provide a value to the 
		caller without returning program flow, then its execution can be resumed later from the same 
		point where it was suspended.
		At first look a Pscript thread can be confused with a generator, in fact their behaviour is quite similar.
		However while a generator runs in the caller stack and can suspend only the local routine stack a thread 
		has its own execution stack, global table and error handler; This allows a thread to suspend nested calls and
		have it's own error policies.
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1965"></a>Using threads</h3></div></div><div></div></div><a class="indexterm" name="d0e1966"></a><p>
			</p><p>
			Threads are created through the built-in function 'newthread(func)'; this function
			gets as parameter a pscript function and bind it to the new thread objecs(will be the thread body).
			The returned thread object is initially in 'idle' state. the thread can be started with the function
			'threadobj.call()'; the parameters passed to 'call' are passed to the thread function.
			</p><p>
			</p><p>
			A thread can be be suspended calling the function suspend(), when this happens the function
			that wokeup(or started) the thread returns (If a parametrer is passed to suspend() it will
			be the return value of the wakeup function , if no parameter is passed the return value will be null).
			A suspended thread can be resumed calling the funtion 'threadobj.wakeup', when this happens
			the function that suspended the thread will return(if a parameter is passed	to wakeup it will
			be the return value of the suspend function, if no parameter is passed the return value will be null).
			</p><p>
			</p><p>			
			A thread terminates when its main function returns or when an unhandled	exception occurs during its execution.
			</p><p>
		
		</p><pre class="programlisting">
function coroutine_test(a,b)
{
	::print(a+" "+b+"\n");
	local ret = ::suspend("suspend 1");
	::print("the coroutine says "+ret+"\n");
	ret = ::suspend("suspend 2");
	::print("the coroutine says "+ret+"\n");
	ret = ::suspend("suspend 3");
	::print("the coroutine says "+ret+"\n");
	return "I'm done"
}

local coro = ::newthread(coroutine_test);

local susparam = coro.call("test","coroutine"); //starts the coroutine

local i = 1;
do
{
	::print("suspend passed ("+susparam+")\n")
	susparam = coro.wakeup("ciao "+i);
	++i;
}while(coro.getstatus()=="suspended")

::print("return passed ("+susparam+")\n")
		</pre><p>
		</p><p>the result of this program will be</p><p>
		</p><pre class="programlisting">
test coroutine
suspend passed (suspend 1)
the coroutine says ciao 1
suspend passed (suspend 2)
the coroutine says ciao 2
suspend passed (suspend 3)
the coroutine says ciao 3
return passed (I'm done).
		</pre><p>
		
		the following is an interesting example of how threads and tail recursion
		can be combined.
</p><pre class="programlisting">		
function state1()
{
	::suspend("state1");
	return state2(); //tail call
}

function state2()
{
	::suspend("state2");
	return state3(); //tail call
}

function state3()
{
	::suspend("state3");
	return state1(); //tail call
}

local statethread = ::newthread(state1)

::print(statethread.call()+"\n");

for(local i = 0; i &lt; 10000; i++)
	::print(statethread.wakeup()+"\n");
</pre><p>	
		</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1995"></a>Weak References</h2></div></div><div></div></div><a class="indexterm" name="d0e1996"></a><a name="weakrefs"></a><p>
			The weak references allows the programmers to create references to objects without
			influencing the lifetime of the object itself.
			In pscript Weak references are first-class objects created through the built-in method obj.weakref().
			All types except null implement the weakref() method; however in bools,integers and float the method
			simply returns the object itself(this because this types are always passed by value).
			When a weak references is assigned to a container (table slot,array,class or
			instance) is treated differently than other objects; When a container slot that hold a weak
			reference is fetched, it always returns the value pointed by the weak reference instead of the weak
			reference object. This allow the programmer to ignore the fact that the value handled is weak.
			When the object pointed by weak reference is destroyed, the weak reference is automatically set to null.
			</p><p>
			</p><pre class="programlisting">
local t = {}
local a = ["first","second","third"]
//creates a weakref to the array and assigns it to a table slot
t.thearray &lt;- a.weakref();
			</pre><p>
			The table slot 'thearray' contains a weak reference to an array.
			The following line prints "first", because tables(and all other containers) always return
			the object pointed by a weak ref
			</p><pre class="programlisting">
print(t.thearray[0]);
			</pre><p>
			the only strong reference to the array is owned by the local variable 'a', so
			because the following line assigns a integer to 'a' the array is destroyed.
			</p><pre class="programlisting">
a = 123;
			</pre><p>
			When an object pointed by a weak ref is destroyed the weak ref is automatically set to null,
			so the following line will print "null".
			</p><pre class="programlisting">
::print(typeof(t.thearray))
			</pre><p>
			</p><p>
			</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2019"></a>Handling weak references explicitly</h3></div></div><div></div></div><p>
			If a weak reference is assigned to a local variable, then is treated as any other value.
			</p><pre class="programlisting">
local t = {}
local weakobj = t.weakref();
			</pre><p>
			the following line prints "weakref".
			</p><pre class="programlisting">
::print(typeof(weakobj))
			</pre><p>
			the object pointed by the weakref can be obtained through the built-in method weakref.ref().
			</p><p>
			The following line prints "table".
			</p><pre class="programlisting">
::print(typeof(weakobj.ref()))
			</pre><p>
			</p><p>
			</p></div><p>
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2038"></a>Delegation</h2></div></div><div></div></div><a class="indexterm" name="d0e2039"></a><a name="delegation"></a><p>
			Pscript supports implicit delegation. Every table or userdata can have a parent table
			(delegate). A parent table is a normal table that allows the definition of special behaviors
			for his child.
			When a table (or userdata) is indexed with a key that doesn&#8217;t correspond to one of its
			slots, the interpreter automatically delegates the get (or set) operation to its parent.
		</p><pre class="programlisting">
  
Entity &lt;- {
}

function Entity::DoStuff()
{
    ::print(_name);
}

local newentity = {
    _name=&#8221;I&#8217;m the new entity&#8221;
}
newentity.setdelegate(Entity)

newentity.DoStuff(); //prints &#8220;I&#8217;m the new entity&#8221;
		</pre><p>
			The delegate of a table can be retreived through built-in method <tt class="literal">table.getdelegate()</tt>.
		</p><pre class="programlisting">
local thedelegate = newentity.getdelegate();
		</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2057"></a>Metamethods</h2></div></div><div></div></div><a class="indexterm" name="d0e2058"></a><a name="metamethods"></a><p>
      Metamethods are a mechanism that allows the customization of certain aspects of the
      language semantics. Those methods are normal functions placed in a table
      parent(delegate) or class declaration; Is possible to change many aspect of a table/class instance behavior by just defining
      a metamethod. Class objects(not instances) supports only 2 metamethods _newmember,_inherited.
      </p><p>
			For example when we use relational operators other than &#8216;==&#8217; on 2 tables, the VM will
			check if the table has a method in his parent called &#8216;_cmp&#8217; if so it will call it to determine
			the relation between the tables.
		
		</p><pre class="programlisting">
  
local comparable={
    _cmp = function (other)
    {
        if(name&lt;other.name)return &#8211;1;
        if(name&gt;other.name)return 1;
        return 0;
    }
}

local a={ name="Alberto" }.setdelegate(comparable);
local b={ name="Wouter" }.setdelegate(comparable);

if(a&gt;b)
    print("a&gt;b")
else
    print("b&lt;=a");
</pre><p>
		</p><p>		
		</p><p>
		for classes the previous code become:
		
</p><pre class="programlisting">
class Comparable {
	constructor(n)
	{
		name = n;
	}
	function _cmp(other)
	{
		if(name&lt;other.name) return -1;
		if(name&gt;other.name) return 1;
		return 0;
	}
	name = null;
}

local a = Comparable("Alberto");
local b = Comparable("Wouter");

if(a&gt;b)
    print("a&gt;b")
else
    print("b&lt;=a");

</pre><p>
			</p><p>
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2079"></a>_set</h3></div></div><div></div></div><a class="indexterm" name="d0e2080"></a><p>
        invoked when the index idx is not present in the object or in its delegate chain.
        _set must 'throw null' to notify that a key wasn't found but the there were not runtime errors(clean failure).
        This allows the program to defferentieate between a runtime error and a 'index not found'.
      </p><pre class="programlisting">function _set(idx,val) //returns val</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2092"></a>_get</h3></div></div><div></div></div><a class="indexterm" name="d0e2093"></a><p>
        invoked when the index idx is not present in the object or in its delegate chain.
        _get must 'throw null' to notify that a key wasn't found but the there were not runtime errors(clean failure).
        This allows the program to defferentieate between a runtime error and a 'index not found'.
      </p><pre class="programlisting">function _get(idx) //return the fetched values</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2105"></a>_newslot</h3></div></div><div></div></div><a class="indexterm" name="d0e2106"></a><p>invoked when a script tries to add a new slot in a table.</p><pre class="programlisting">function _newslot(key,value) //returns val</pre><p>
				if the slot already exists in the target table the method will not be invoked also if the
				&#8220;new slot&#8221; operator is used.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2120"></a>_delslot</h3></div></div><div></div></div><a class="indexterm" name="d0e2121"></a><p>invoked when a script deletes a slot from a table.</p><p>if the method is invoked pscript will not try to delete the slot himself</p><pre class="programlisting">function _delslot(key)</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2135"></a>_add</h3></div></div><div></div></div><a class="indexterm" name="d0e2136"></a><p>the + operator</p><pre class="programlisting">function _add(op) //returns this+op</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2148"></a>_sub</h3></div></div><div></div></div><a class="indexterm" name="d0e2149"></a><p>the &#8211; operator (like _add)</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2159"></a>_mul</h3></div></div><div></div></div><a class="indexterm" name="d0e2160"></a><p>the * operator (like _add)</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2170"></a>_div</h3></div></div><div></div></div><a class="indexterm" name="d0e2171"></a><p>the / operator (like _add)</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2181"></a>_modulo</h3></div></div><div></div></div><a class="indexterm" name="d0e2182"></a><p>the % operator (like _add)</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2192"></a>_unm</h3></div></div><div></div></div><a class="indexterm" name="d0e2193"></a><p>the unary minus operator</p><pre class="programlisting">function _unm()</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2205"></a>_typeof</h3></div></div><div></div></div><a class="indexterm" name="d0e2206"></a><p>invoked by the typeof operator on tables ,userdata and class instances</p><pre class="programlisting">function _typeof() //returns the type of this as string</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2218"></a>_cmp</h3></div></div><div></div></div><a class="indexterm" name="d0e2219"></a><p>invoked to emulate the &lt; &gt; &lt;= &gt;= operators</p><pre class="programlisting">function _cmp(other)</pre><p>
				<tt class="literal">returns an integer:</tt>
				</p><div class="informaltable"><table border="0"><colgroup><col><col></colgroup><tbody><tr><td><tt class="literal">&gt;0</tt></td><td><tt class="literal">if this &gt; other</tt></td></tr><tr><td><tt class="literal">0</tt></td><td><tt class="literal">if this == other</tt></td></tr><tr><td><tt class="literal">&lt;0</tt></td><td><tt class="literal">if this &lt; other</tt></td></tr></tbody></table></div><p>
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2263"></a>_call</h3></div></div><div></div></div><a class="indexterm" name="d0e2264"></a><p>invoked when a table, userdata or class instance is called</p><pre class="programlisting">function _call(original_this,params&#8230;)</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2276"></a>_cloned</h3></div></div><div></div></div><a class="indexterm" name="d0e2277"></a><p>invoked when a table or class instance is cloned(in the cloned table)</p><pre class="programlisting">function _cloned(original)</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2289"></a>_nexti</h3></div></div><div></div></div><a class="indexterm" name="d0e2290"></a><p>invoked when a userdata or class instance is iterated by a foreach loop</p><pre class="programlisting">function _nexti(previdx)</pre><p>
				if previdx==null it means that it is the first iteration.
				The function has to return the index of the &#8216;next&#8217; value.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2304"></a>_tostring</h3></div></div><div></div></div><a class="indexterm" name="d0e2305"></a><p>invoked when during string conacatenation or when the <tt class="literal">print</tt> function prints a table, instance or userdata.
			The method is also invoked by the ps_tostring() api</p><pre class="programlisting">function _tostring()</pre><p>
				must return a string representation of the object.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2322"></a>_inherited</h3></div></div><div></div></div><a class="indexterm" name="d0e2323"></a><p>
        invoked when a class object inherits from the class implementing <tt class="literal">_inherited</tt>
        the <tt class="literal">this</tt> contains the new class.
      </p><pre class="programlisting">function _inherited(attributes)</pre><p>
        return value is ignored.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2343"></a>_newmember</h3></div></div><div></div></div><a class="indexterm" name="d0e2344"></a><p>
        invoked for each member declared in a class body(at declaration time).
      </p><pre class="programlisting">function _newmember(index,value,attributes,isstatic)</pre><p>
        if the function is implemented, members will not be added to the class.
      </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2358"></a>Built-in functions</h2></div></div><div></div></div><a name="builtin"></a><p>The pscript virtual machine has a set of built utility functions.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2365"></a>Global symbols</h3></div></div><div></div></div><p>
				<a class="indexterm" name="d0e2370"></a>
				</p><p><tt class="function">array(size,[fill])</tt></p><p>
				create and returns array of a specified size.if the optional parameter <i class="parameter"><tt>fill</tt></i> is specified
					its value will be used to fill the new array's slots. 
					If the <i class="parameter"><tt>fill</tt></i> paramter is omitted <tt class="literal">null</tt> is used instead.
			</p><p>
				<a class="indexterm" name="d0e2389"></a>
				</p><p><tt class="function">seterrorhandler(func)</tt></p><p>
				sets the runtime error handler
			</p><p>
        <a class="indexterm" name="d0e2399"></a>
        </p><p><tt class="function">callee()</tt></p><p>
        returns the currently running closure
      </p><p>
				<a class="indexterm" name="d0e2409"></a>
				</p><p><tt class="function">setdebughook(hook_func)</tt></p><p>
				sets the debug hook
			</p><p>
				<a class="indexterm" name="d0e2419"></a>
				</p><p><tt class="function">enabledebuginfo(enable)</tt></p><p>
				enable/disable the debug line information generation at compile time.
				enable != null enables . enable == null disables.
			</p><p>
				<a class="indexterm" name="d0e2429"></a>
				</p><p><tt class="function">getroottable()</tt></p><p>
				returns the root table of the VM.
			</p><p>
        <a class="indexterm" name="d0e2439"></a>
        </p><p><tt class="function">setroottable(table)</tt></p><p>
        sets the root table of the VM. And returns the previous root table.
      </p><p>
        <a class="indexterm" name="d0e2449"></a>
        </p><p><tt class="function">getconsttable()</tt>
        </p><p>returns the const table of the VM.
      </p><p><a class="indexterm" name="d0e2459"></a>
        </p><p><tt class="function">setconsttable(table)</tt></p><p>
        sets the const table of the VM. And returns the previous const table.
      </p><p>
				<a class="indexterm" name="d0e2469"></a>
				</p><p><tt class="function">assert(exp)</tt></p><p>
				throws an exception if exp is null
			</p><p>
				<a class="indexterm" name="d0e2479"></a>
				</p><p><tt class="function">print(x)</tt></p><p>
				prints x in the standard output
			</p><p>
        <a class="indexterm" name="d0e2489"></a>
        </p><p><tt class="function">error(x)</tt></p><p>
        prints x in the standard error output
      </p><p>
				<a class="indexterm" name="d0e2499"></a>
				</p><p><tt class="function">compilestring(string,[buffername])</tt></p><p>
				compiles a string containing a pscript script into a function and
				returns it
				</p><pre class="programlisting">
local compiledscript=compilestring("::print(\"ciao\")");
//run the script				
compiledscript();
				</pre><p>
			</p><p>
				<a class="indexterm" name="d0e2512"></a>
				</p><p><tt class="function">collectgarbage()</tt></p><p>
        runs the garbage collector and returns the number of reference cycles found(and deleted)
        This function only works on garbage collector builds.
      </p><p>
        <a class="indexterm" name="d0e2522"></a>
        </p><p><tt class="function">resurrectunreachable()</tt></p><p>
        runs the garbage collector and returns an array containing all unreachable object found.
        If no unreachable object is found, null is returned instead. This function is meant to help debugging reference cycles.
        This function only works on garbage collector builds.
      </p><p>
				<a class="indexterm" name="d0e2532"></a>
				</p><p><tt class="function">type(obj)</tt></p><p>
				return the 'raw' type of an object without invoking the metatmethod '_typeof'.
			</p><p>
				<a class="indexterm" name="d0e2542"></a>
				</p><p><tt class="function">getstackinfos(level)</tt></p><p>
				returns the stack informations of a given call stack level.
				returns a table formatted as follow:
				</p><pre class="programlisting">
{
	func="DoStuff",	//function name
	
	src="test.nut",	//source file
	
	line=10,		//line number
	
	locals = {		//a table containing the local variables
	
		a=10,
		
		testy="I'm a string"
	}
}
				</pre><p>
				level = 0 is the current function, 
				level = 1 is the caller and so on.
				If the stack level doesn't exist the function returns null.
			</p><p>
				<a class="indexterm" name="d0e2555"></a>
				</p><p><tt class="function">newthread(threadfunc)</tt></p><p>
				creates a new cooperative thread object(coroutine) and returns it
			</p><p>
        <a class="indexterm" name="d0e2565"></a>
        </p><p><tt class="function">_versionnumber_</tt></p><p>
        integer values describing the version of VM and compiler.
        eg. for Pscript 3.0.1 this value will be 301
      </p><p>
        <a class="indexterm" name="d0e2575"></a>
        </p><p><tt class="function">_version_</tt></p><p>
        string values describing the version of VM and compiler.
      </p><p>
        <a class="indexterm" name="d0e2585"></a>
        </p><p><tt class="function">_charsize_</tt>
        </p><p> 
        size in bytes of the internal VM rapresentation for characters(1 for ASCII builds 2 for UNICODE builds).
      </p><p>
        <a class="indexterm" name="d0e2596"></a>
        </p><p><tt class="function">_intsize_</tt></p><p>
        size in bytes of the internal VM rapresentation for integers(4 for 32bits builds 8 for 64bits builds).
      </p><p>
        <a class="indexterm" name="d0e2606"></a>
        </p><p><tt class="function">_floatsize_</tt></p><p>
        size in bytes of the internal VM rapresentation for floats(4 for single precision builds 8 for double precision builds).
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2615"></a>Default delegates</h3></div></div><div></div></div><p>
				Except null and userdata every pscript object has a default delegate containing a set of
				functions to manipulate and retrieve information from the object itself.
			</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2621"></a>Integer</h4></div></div><div></div></div><p>
					<a class="indexterm" name="d0e2626"></a>
					</p><p><tt class="function">tofloat()</tt></p><p>
					convert the number to float and returns it
				</p><p>
					<a class="indexterm" name="d0e2638"></a>
					</p><p><tt class="function">tostring()</tt></p><p>
					converts the number to string and returns it
				</p><p>
					<a class="indexterm" name="d0e2650"></a>
					</p><p><tt class="function">tointeger()</tt></p><p>
					returns the value of the integer(dummy function)
				</p><p>
					<a class="indexterm" name="d0e2662"></a>
					</p><p><tt class="function">tochar()</tt></p><p>
					returns a string containing a single character rapresented by the integer.
				</p><p>
					<a class="indexterm" name="d0e2674"></a>
					</p><p><tt class="function">weakref()</tt></p><p>
					dummy function, returns the integer itself.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2685"></a>Float</h4></div></div><div></div></div><p>
					<a class="indexterm" name="d0e2690"></a>
					</p><p><tt class="function">tofloat()</tt></p><p>
					returns the value of the float(dummy function)
				</p><p>
					<a class="indexterm" name="d0e2702"></a>
					</p><p><tt class="function">tointeger()</tt></p><p>
					converts the number to integer and returns it
				</p><p>
					<a class="indexterm" name="d0e2714"></a>
					</p><p><tt class="function">tostring()</tt></p><p>
					converts the number to string and returns it
				</p><p>
					<a class="indexterm" name="d0e2726"></a>
					</p><p><tt class="function">tochar()</tt></p><p>
					returns a string containing a single character rapresented by the integer part of the float.
				</p><p>
					<a class="indexterm" name="d0e2738"></a>
					</p><p><tt class="function">weakref()</tt></p><p>
					dummy function, returns the float itself.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2749"></a>Bool</h4></div></div><div></div></div><p>
					<a class="indexterm" name="d0e2754"></a>
					</p><p><tt class="function">tofloat()</tt></p><p>
					returns 1.0 for <tt class="literal">true</tt> 0.0 for <tt class="literal">false</tt>
				</p><p>
					<a class="indexterm" name="d0e2772"></a>
					</p><p><tt class="function">tointeger()</tt></p><p>
					returns 1 for <tt class="literal">true</tt> 0 for <tt class="literal">false</tt>
				</p><p>
					<a class="indexterm" name="d0e2790"></a>
					</p><p><tt class="function">tostring()</tt></p><p>
					returns "true" for <tt class="literal">true</tt> "false" for <tt class="literal">false</tt>
				</p><p>
					<a class="indexterm" name="d0e2808"></a>
					</p><p><tt class="function">weakref()</tt></p><p>
					dummy function, returns the bool itself.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2819"></a>String</h4></div></div><div></div></div><p>
					<a class="indexterm" name="d0e2824"></a>
					</p><p><tt class="function">len()</tt></p><p>
					returns the string length
				</p><p>
					<a class="indexterm" name="d0e2836"></a>
					</p><p><tt class="function">tointeger()</tt></p><p>
					converts the string to integer and returns it
				</p><p>
					<a class="indexterm" name="d0e2848"></a>
					</p><p><tt class="function">tofloat()</tt></p><p>
					converts the string to float and returns it
				</p><p>
					<a class="indexterm" name="d0e2860"></a>
					</p><p><tt class="function">tostring()</tt></p><p>
					returns the string(dummy function)
				</p><p>
					<a class="indexterm" name="d0e2872"></a>
					</p><p><tt class="function">slice(start,[end])</tt></p><p>
					returns a section of the string as new string. Copies from start to the end (not included).
					If start is negative the index is calculated as length + start, if end is negative the index is
					calculated as length + end. If end is omitted end is equal to the string length.
				</p><p>
					<a class="indexterm" name="d0e2884"></a>
					</p><p><tt class="function">find(substr,[startidx])</tt></p><p>
					search a sub string(substr) starting from the index startidx and returns the index of its
					first occurrence. If startidx is omitted the search operation starts from the beginning of
					the string. The function returns null if substr is not found.
				</p><p>
					<a class="indexterm" name="d0e2896"></a>
					</p><p><tt class="function">tolower()</tt></p><p>
					returns a lowercase copy of the string.
				</p><p>
					<a class="indexterm" name="d0e2908"></a>
					</p><p><tt class="function">toupper()</tt></p><p>
					returns a uppercase copy of the string.
				</p><p>
					<a class="indexterm" name="d0e2920"></a>
					</p><p><tt class="function">weakref()</tt></p><p>
					returns a weak reference to the object.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2931"></a>Table</h4></div></div><div></div></div><p>
					<a class="indexterm" name="d0e2936"></a>
					</p><p><tt class="function">len()</tt></p><p>
					returns the number of slots contained in a table
				</p><p>
					<a class="indexterm" name="d0e2948"></a>
					</p><p><tt class="function">rawget(key)</tt></p><p>
          tries to get a value from the slot &#8216;key&#8217; without employing delegation
        </p><p>
					<a class="indexterm" name="d0e2960"></a>
					</p><p><tt class="function">rawset(key,val)</tt></p><p>
					sets the slot &#8216;key&#8217; with the value &#8216;val&#8217; without employing delegation.
					If the slot does not exists , it will be created.
				</p><p>
					<a class="indexterm" name="d0e2972"></a>
					</p><p><tt class="function">rawdelete()</tt></p><p>
					deletes the slot key without emplying delegetion and retunrs his value.
					if the slo does not exists returns always null.
				</p><p>
					<a class="indexterm" name="d0e2984"></a>
					</p><p><tt class="function">rawin(key)</tt></p><p>
					returns true if the slot &#8216;key&#8217; exists.
					the function has the same eddect as the operator 'in' but does not employ delegation.
				</p><p>
					<a class="indexterm" name="d0e2996"></a>
					</p><p><tt class="function">weakref()</tt></p><p>
					returns a weak reference to the object.
				</p><p>
					<a class="indexterm" name="d0e3008"></a>
					</p><p><tt class="function">tostring()</tt></p><p>
					tries to invoke the _tostring metamethod, if failed. returns "(table : pointer)".
				</p><p>
          <a class="indexterm" name="d0e3020"></a></p><p><tt class="function">clear()</tt></p><p>
          removes all the slot from the table
        </p><p>
          <a class="indexterm" name="d0e3031"></a>
          </p><p><tt class="function">setdelegate(table)</tt></p><p>
          sets the delegate of the table, to remove a delegate 'null' must be passed to the function.
          The function returns the table itself (eg. a.setdelegate(b) in this case 'a' is the return value).
        </p><p><a class="indexterm" name="d0e3042"></a>
          </p><p><tt class="function">getdelegate()</tt></p><p>
          returns the table's delegate or null if no delegate was set.
        </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3053"></a>Array</h4></div></div><div></div></div><p>
					<a class="indexterm" name="d0e3058"></a>
					</p><p><tt class="function">len()</tt></p><p>
					returns the length of the array
				</p><p>
					<a class="indexterm" name="d0e3070"></a>
					</p><p><tt class="function">append(val)</tt></p><p>
					appends the value &#8216;val&#8217; at the end of the array
				</p><p>
          <a class="indexterm" name="d0e3082"></a>
          </p><p><tt class="function">push(val)</tt></p><p>appends the value &#8216;val&#8217; at the end of the array</p><p>
					<a class="indexterm" name="d0e3094"></a>
					</p><p><tt class="function">extend(array)</tt></p><p>
					Extends the array by appending all the items in the given array.
				</p><p>
					<a class="indexterm" name="d0e3106"></a>
					</p><p><tt class="function">pop()</tt></p><p>
					removes a value from the back of the array and returns it.
				</p><p>
					<a class="indexterm" name="d0e3118"></a>
					</p><p><tt class="function">top()</tt></p><p>
					returns the value of the array with the higher index
				</p><p>
					<a class="indexterm" name="d0e3130"></a>
					</p><p><tt class="function">insert(idx,val)</tt></p><p>
					inserst the value &#8216;val&#8217; at the position &#8216;idx&#8217; in the array
				</p><p>
					<a class="indexterm" name="d0e3142"></a>
					</p><p><tt class="function">remove(idx)</tt></p><p>
					removes the value at the position &#8216;idx&#8217; in the array
				</p><p>
					<a class="indexterm" name="d0e3154"></a>
					</p><p><tt class="function">resize(size,[fill])</tt></p><p>
					resizes the array, if the optional parameter <i class="parameter"><tt>fill</tt></i> is specified
					its value will be used to fill the new array's slots(if the size specified is bigger than the previous size) . 
					If the <i class="parameter"><tt>fill</tt></i> paramter is omitted <tt class="literal">null</tt> is used instead.
				</p><p>
					<a class="indexterm" name="d0e3175"></a>
					</p><p><tt class="function">sort([compare_func])</tt></p><p>
					sorts the array.
					a custom compare function can be optionally passed.The function prototype as to be the
					following.
					</p><pre class="programlisting">
function custom_compare(a,b)
{
	if(a&gt;b) return 1
	else if(a&lt;b) return -1
	return 0;
}
					</pre><p>
          
          a more compact version of a custom compare can be written using a lambda expression and the operator &lt;=&gt;
         </p><pre class="programlisting">
arr.sort(@(a,b) a &lt;=&gt; b);
        </pre><p>
        </p><p>
					<a class="indexterm" name="d0e3193"></a>
					</p><p><tt class="function">reverse()</tt></p><p>
					reverse the elements of the array in place
				</p><p>
					<a class="indexterm" name="d0e3205"></a>
					</p><p><tt class="function">slice(start,[end])</tt></p><p>
					returns a section of the array as new array. Copies from start to the end (not included).
					If start is negative the index is calculated as length + start, if end is negative the index is
					calculated as length + end. If end is omitted end is equal to the array length.
				</p><p>
					<a class="indexterm" name="d0e3217"></a>
					</p><p><tt class="function">weakref()</tt></p><p>
					returns a weak reference to the object.
				</p><p>
					<a class="indexterm" name="d0e3229"></a>
					</p><p><tt class="function">tostring()</tt></p><p>
					returns the string "(array : pointer)".
				</p><p>
          <a class="indexterm" name="d0e3241"></a></p><p><tt class="function">clear()</tt></p><p>
          removes all the items from the array
        </p><p>
          <a class="indexterm" name="d0e3252"></a></p><p><tt class="function">map(func(a))</tt></p><p>
          creates a new array of the same size.
          for each element in the original array invokes the function 'func' and
          assigns the return value of the function to the corresponding element of the newly created array.
        </p><p>
          <a class="indexterm" name="d0e3263"></a>
          </p><p><tt class="function">apply(func(a))</tt></p><p>
           for each element in the array invokes the function 'func' and
          replace the original value of the element with the return value of the function.
        </p><p>
          <a class="indexterm" name="d0e3275"></a>
          </p><p><tt class="function">reduce(func(prevval,curval))</tt></p><p>
          Reduces an array to a single value.
          For each element in the array invokes the function 'func' passing the initial value (or value from the previous callback call)
          and the value of the current element. the return value of the function is then used as 'prevval' for the next element.
          Given an array of length 0, returns null. Given an array of length 1, returns the first element.
          Given an array with 2 or more elements calls the function with the first two elements as the parameters, gets that result, 
          then calls the function with that result and the third element, gets that result, 
          calls the function with that result and the fourth parameter and so on until all element have been processed.
          Finally returns the return value of the last invocation of func.
        </p><p>
          <a class="indexterm" name="d0e3287"></a>
          </p><p><tt class="function">filter(func(index,val))</tt></p><p>
          Creates a new array with all elements that pass the test implemented by the provided function.
          In detail, it creates a new array, for each element in the original array invokes the specified function
          passing the index of the element and it's value; if the function returns 'true', then the value 
          of the corresponding element is added on the newly created array.
        </p><p>
          <a class="indexterm" name="d0e3299"></a>
          </p><p><tt class="function">find(value)</tt></p><p>
          Performs a linear search for the value in the array. Returns the index of the value if it was found null otherwise.
        </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3310"></a>Function</h4></div></div><div></div></div><p>
					<a class="indexterm" name="d0e3315"></a>
					</p><p><tt class="function">call(_this,args&#8230;)</tt></p><p>
					calls the function with the specified environment object(&#8217;this&#8217;) and parameters
				</p><p>
          <a class="indexterm" name="d0e3327"></a>
          </p><p><tt class="function">pcall(_this,args&#8230;)</tt></p><p>
          calls the function with the specified environment object(&#8217;this&#8217;) and parameters,
          this function will not invoke the error callback in case of failure(pcall stays for
          'protected call')
        </p><p>
					<a class="indexterm" name="d0e3339"></a>
					</p><p><tt class="function">acall(array_args)</tt></p><p>
          calls the function with the specified environment object(&#8217;this&#8217;) and parameters. The
          function accepts an array containing the parameters that will be passed to the called
          function.Where array_args has to contain the required 'this' object at the [0] position.
        </p><p>
          <a class="indexterm" name="d0e3351"></a>
          </p><p><tt class="function">pacall(array_args)</tt></p><p>
          calls the function with the specified environment object(&#8217;this&#8217;) and parameters. The
          function accepts an array containing the parameters that will be passed to the called
          function.Where array_args has to contain the required 'this' object at the [0] position.
          This function will not invoke the error callback in case of failure(pacall stays for
          'protected array call')
        </p><p>
					<a class="indexterm" name="d0e3363"></a>
					</p><p><tt class="function">weakref()</tt></p><p>
					returns a weak reference to the object.
				</p><p>
					<a class="indexterm" name="d0e3375"></a>
					</p><p><tt class="function">tostring()</tt></p><p>
					returns the string "(closure : pointer)".
				</p><p>
          <a class="indexterm" name="d0e3387"></a>
          </p><p><tt class="function">bindenv(env)</tt></p><p>
          clones the function(aka closure) and bind the enviroment object to it(table,class or instance).
          the <tt class="literal">this</tt> parameter of the newly create function will always be set to env.
          Note that the created function holds a weak reference to its environment object so cannot be used to
          control its lifetime.
        </p><p>
          <a class="indexterm" name="d0e3402"></a>
          </p><p><tt class="function">getinfos()</tt></p><p>
          returns a table containing informations about the function, like parameters, name and source name;
</p><pre class="programlisting">
  
//the data is returned as a table is in form
//pure pscript function
{
  native = false
  name = "zefuncname"
  src = "/somthing/something.nut"
  parameters = ["a","b","c"]
  defparams = [1,"def"]
  varargs = 2
}
//native C function
{
  native = true
  name = "zefuncname"
  paramscheck = 2
  typecheck = [83886082,83886384] //this is the typemask (see C defines OT_INTEGER,OT_FLOAT etc...)
}

  
</pre><p>
        </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3416"></a>Class</h4></div></div><div></div></div><p>
          <a class="indexterm" name="d0e3421"></a>
          </p><p><tt class="function">instance()</tt></p><p>
          returns a new instance of the class. this function does not invoke the instance constructor. 
          The constructor must be explicitly called( eg. class_inst.constructor(class_inst) ).
        </p><p>
					<a class="indexterm" name="d0e3433"></a>
					</p><p><tt class="function">getattributes(membername)</tt></p><p>
					returns the attributes of the specified member. if the parameter member is null the function
					returns the class level attributes.
				</p><p>
					<a class="indexterm" name="d0e3445"></a>
					</p><p><tt class="function">setattributes(membername,attr)</tt></p><p>
					sets the attribute of the specified member and returns the previous attribute value.
					if the parameter member is null the function sets the class level attributes.
				</p><p>
					<a class="indexterm" name="d0e3457"></a>
					</p><p><tt class="function">rawin(key)</tt></p><p>
					returns true if the slot &#8216;key&#8217; exists.
					the function has the same eddect as the operator 'in' but does not employ delegation.
				</p><p>
					<a class="indexterm" name="d0e3469"></a>
					</p><p><tt class="function">weakref()</tt></p><p>
					returns a weak reference to the object.
				</p><p>
					<a class="indexterm" name="d0e3481"></a>
					</p><p><tt class="function">tostring()</tt></p><p>
					returns the string "(class : pointer)".
				</p><p>
          <a class="indexterm" name="d0e3493"></a>
          </p><p><tt class="function">rawget(key)</tt></p><p>
          tries to get a value from the slot &#8216;key&#8217; without employing delegation
        </p><p>
          <a class="indexterm" name="d0e3505"></a>
          </p><p><tt class="function">rawset(key,val)</tt></p><p>
          sets the slot &#8216;key&#8217; with the value &#8216;val&#8217; without employing delegation.
          If the slot does not exists , it will be created.
        </p><p>
          <a class="indexterm" name="d0e3517"></a>
          </p><p><tt class="function">newmember(key,val,[attrs],[bstatic])</tt></p><p>
          sets/adds the slot &#8216;key&#8217; with the value &#8216;val&#8217; and attributes 'attrs' and if present invokes the _newmember metamethod.
          If bstatic is true the slot will be added as static.
          If the slot does not exists , it will be created.
        </p><p>
          <a class="indexterm" name="d0e3529"></a>
          </p><p><tt class="function">rawnewmember(key,val,[attrs],[bstatic])</tt></p><p>
          sets/adds the slot &#8216;key&#8217; with the value &#8216;val&#8217; and attributes 'attrs'.If bstatic is true the slot will be added as static.
          If the slot does not exists , it will be created. It doesn't invoke any metamethod.
        </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3540"></a>Class Instance</h4></div></div><div></div></div><p>
					<a class="indexterm" name="d0e3545"></a>
					</p><p><tt class="function">getclass()</tt></p><p>
					returns the class that created the instance.
				</p><p>
					<a class="indexterm" name="d0e3557"></a>
					</p><p><tt class="function">rawin(key)</tt></p><p>
					returns true if the slot &#8216;key&#8217; exists.
					the function has the same eddect as the operator 'in' but does not employ delegation.
				</p><p>
					<a class="indexterm" name="d0e3569"></a>
					</p><p><tt class="function">weakref()</tt></p><p>
					returns a weak reference to the object.
				</p><p>
					<a class="indexterm" name="d0e3581"></a>
					</p><p><tt class="function">tostring()</tt></p><p>
					tries to invoke the _tostring metamethod, if failed. returns "(insatnce : pointer)".
				</p><p>
          <a class="indexterm" name="d0e3593"></a>
          </p><p><tt class="function">rawget(key)</tt></p><p>
          tries to get a value from the slot &#8216;key&#8217; without employing delegation
        </p><p>
          <a class="indexterm" name="d0e3605"></a>
          </p><p><tt class="function">rawset(key,val)</tt></p><p>
          sets the slot &#8216;key&#8217; with the value &#8216;val&#8217; without employing delegation.
          If the slot does not exists , it will be created.
        </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3616"></a>Generator</h4></div></div><div></div></div><p>
					<a class="indexterm" name="d0e3621"></a>
					</p><p><tt class="function">getstatus()</tt></p><p>
					returns the status of the generator as string : &#8220;running&#8221;, &#8221;dead&#8221; or &#8221;suspended&#8221;.
				</p><p>
					<a class="indexterm" name="d0e3633"></a>
					</p><p><tt class="function">weakref()</tt></p><p>
					returns a weak reference to the object.
				</p><p>
					<a class="indexterm" name="d0e3645"></a>
					</p><p><tt class="function">tostring()</tt></p><p>
					returns the string "(generator : pointer)".
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3656"></a>Thread</h4></div></div><div></div></div><p>
					<a class="indexterm" name="d0e3661"></a>
					</p><p><tt class="function">call(...)</tt></p><p>
					starts the thread with the specified parameters
				</p><p>
					<a class="indexterm" name="d0e3673"></a>
					</p><p><tt class="function">wakeup([wakeupval])</tt></p><p>
					wakes up a suspended thread, accepts a optional parameter that will be used
					as return value for the function that suspended the thread(usually suspend())
				</p><p>
					<a class="indexterm" name="d0e3685"></a>
					</p><p><tt class="function">getstatus()</tt></p><p>
					returns the status of the thread ("idle","running","suspended")
				</p><p>
					<a class="indexterm" name="d0e3697"></a>
					</p><p><tt class="function">weakref()</tt></p><p>
					returns a weak reference to the object.
				</p><p>
					<a class="indexterm" name="d0e3709"></a>
					</p><p><tt class="function">tostring()</tt></p><p>
					returns the string "(thread : pointer)".
				</p><p>
          <a class="indexterm" name="d0e3721"></a>
          </p><p><tt class="function">getstackinfos(stacklevel)</tt></p><p>
          returns the stack frame informations at the given stack level (0 is the current function 1 is the caller and so on).
        </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3732"></a>Weak Reference</h4></div></div><div></div></div><p>
					<a class="indexterm" name="d0e3737"></a>
					</p><p><tt class="function">ref()</tt></p><p>
					returns the object that the weak reference is pointing at, null if the object that
					was point at was destroyed.
				</p><p>
					<a class="indexterm" name="d0e3749"></a>
					</p><p><tt class="function">weakref()</tt></p><p>
					returns a weak reference to the object.
				</p><p>
					<a class="indexterm" name="d0e3761"></a>
					</p><p><tt class="function">tostring()</tt></p><p>
					returns the string "(weakref : pointer)".
				</p></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e3772"></a>Chapter&nbsp;3.&nbsp;Embedding Pscript</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#d0e3783">Memory management</a></span></dt><dt><span class="sect1"><a href="#d0e3800">Unicode</a></span></dt><dt><span class="sect1"><a href="#d0e3806">Pscript on 64 bits architectures</a></span></dt><dt><span class="sect1"><a href="#d0e3811">Userdata alignment</a></span></dt><dt><span class="sect1"><a href="#d0e3819">Stand-alone VM without compiler</a></span></dt><dt><span class="sect1"><a href="#d0e3825">Error conventions</a></span></dt><dt><span class="sect1"><a href="#d0e3833">Initializing Pscript</a></span></dt><dt><span class="sect1"><a href="#d0e3849">The Stack</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e3855">Stack indexes</a></span></dt><dt><span class="sect2"><a href="#d0e3933">Stack manipulation</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e4000">Runtime error handling</a></span></dt><dt><span class="sect1"><a href="#d0e4011">Compiling a script</a></span></dt><dt><span class="sect1"><a href="#d0e4046">Calling a function</a></span></dt><dt><span class="sect1"><a href="#d0e4060">Create a C function</a></span></dt><dt><span class="sect1"><a href="#d0e4108">Tables and arrays manipulation</a></span></dt><dt><span class="sect1"><a href="#d0e4177">Userdata and UserPointers</a></span></dt><dt><span class="sect1"><a href="#d0e4201">The registry table</a></span></dt><dt><span class="sect1"><a href="#d0e4213">Mantaining strong references to Pscript values from the C API</a></span></dt><dt><span class="sect1"><a href="#d0e4221">Debug Interface</a></span></dt></dl></div><p>
		<span class="emphasis"><em>
			This section describes how to embed Pscript in a host application, C language
			knowledge is required to understand this part of the manual.
		</em></span>
	</p><p>
		Because of his nature of extension language, Pscript&#8217;s compiler and virtual machine are
		implemented as C library.
		The library exposes a set of functions to compile scripts, call functions, manipulate data
		and extend the virtual machine.
		All declarations needed for embedding the language in an application are in the header
		file &#8216;pscript.h&#8217;.
	</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3783"></a>Memory management</h2></div></div><div></div></div><p>
			Pscript uses reference counting (RC) as primary system for memory management;
			however, the virtual machine (VM) has an auxiliary
			mark and sweep garbage collector that can be invoked on demand.
		</p><p>
			There are 2 possible compile time options:
		</p><div class="itemizedlist"><ul type="disc"><li><p>
				The default configuration consists in RC plus a mark and sweep garbage collector. 
				The host program can call the function ps_collectgarbage() and perform a garbage collection cycle
				during the program execution. The garbage collector isn&#8217;t invoked by the VM and has to
				be explicitly called by the host program.
			</p></li><li><p>
				The second a situation consists in RC only(define NO_GARBAGE_COLLECTOR); in this case is impossible for
				the VM to detect reference cycles, so is the programmer that has to solve them explicitly in order to
				avoid memory leaks.
			</p></li></ul></div><p>
			The only advantage introduced by the second option is that saves 2 additional
			pointers that have to be stored for each object in the default configuration with 
			garbage collector(8 bytes for 32 bits systems).
			The types involved are: tables, arrays, functions, threads, userdata and generators; all other
			types are untouched. These options do not affect execution speed.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3800"></a>Unicode</h2></div></div><div></div></div><p>
      By default Pscript strings are plain 8-bits ASCII characters; however if the symbol
      'PSUNICODE' is defined the VM, compiler and API will use 16-bits characters.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3806"></a>Pscript on 64 bits architectures</h2></div></div><div></div></div><p>
      Pscript can be compiled on 64 bits architectures by defining '_PS64' in the C++
      preprocessor. This flag should be defined in any project that includes 'pscript.h'.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3811"></a>Userdata alignment</h2></div></div><div></div></div><p>
      Both class instances and userdatas can have a buffer associated to them.
      Pscript specifies the alignment(in bytes) through the peroprocessor defining 'PS_ALIGNMENT'.
      By default PS_ALIGNMENT is defined as 4 for 32 bits builds and 8 for 64bits builds and builds that use 64bits floats.
      It is possible to override the value of PS_ALIGNMENT respecting the following rules.
      PS_ALIGNMENT shall be less than or equal to PS_MALLOC alignments, and it shall be power of 2.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>This only applies for userdata allocated by the VM, specified via ps_setclassudsize() or belonging to a userdata object.
      userpointers specified by the user are not affected by alignemnt rules.</div><p>
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3819"></a>Stand-alone VM without compiler</h2></div></div><div></div></div><p>
      Pscript's VM can be compiled without it's compiler by defining 'NO_COMPILER' in the C++ preprocessor.
      When 'NO_COMPILER' is defined all function related to the compiler (eg. ps_compile) will fail. Other functions
      that conditionally load precompiled bytecode or compile a file (eg. psstd_dofile) will only work with
      precompiled bytecode.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3825"></a>Error conventions</h2></div></div><div></div></div><p>
			Most of the functions in the API return a PSRESULT value; PSRESULT indicates if a
			function completed successfully or not.
			The macros PS_SUCCEEDED() and PS_FAILED() are used to test the result of a function.
		</p><pre class="programlisting">
if(PS_FAILED(ps_getstring(v,-1,&amp;s)))
    printf(&#8220;getstring failed&#8221;);
		</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3833"></a>Initializing Pscript</h2></div></div><div></div></div><p>
			The first thing that a host application has to do, is create a virtual machine.
			The host application can create any number of virtual machines through the function
			<tt class="literal">ps_open()</tt>.
		</p><p>
			Every single VM has to be released with the function <tt class="literal">ps_close()</tt> when it is not
			needed anymore.
		</p><pre class="programlisting">
int main(int argc, char* argv[])
{
    HPSCRIPTVM v;
    v = ps_open(1024); //creates a VM with initial stack size 1024
    
    //do some stuff with pscript here
    
    ps_close(v);
}
		</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3849"></a>The Stack</h2></div></div><div></div></div><p>
			Pscript exchanges values with the virtual machine through a stack. This mechanism has
			been inherited from the language Lua.
			For instance to call a Pscript function from C it is necessary to push the function and the
			arguments in the stack and then invoke the function; also when Pscript calls a C
			function the parameters will be in the stack as well.
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3855"></a>Stack indexes</h3></div></div><div></div></div><p>
				Many API functions can arbitrarily refer to any element in the stack through an index.
				The stack indexes follow those conventions:
				</p><div class="itemizedlist"><ul type="disc"><li>1 is the stack base</li><li>
						Negative indexes are considered an offset from top of the stack. For instance &#8211;1 is
						the top of the stack.
					</li><li>0 is an invalid index</li></ul></div><p>
			</p><p>Here an example (let&#8217;s pretend that this table is the VM stack)</p><div class="informaltable"><table border="1"><colgroup><col><col><col><col></colgroup><tbody><tr><td><span class="emphasis"><em>STACK</em></span></td><td>&nbsp;</td><td><span class="emphasis"><em>positive index</em></span></td><td><span class="emphasis"><em>negative index</em></span></td></tr><tr><td><tt class="literal">"test"</tt></td><td>&nbsp;</td><td>4</td><td>-1(top)</td></tr><tr><td><tt class="literal">1</tt></td><td>&nbsp;</td><td>3</td><td>-2</td></tr><tr><td><tt class="literal">0.5</tt></td><td>&nbsp;</td><td>2</td><td>-3</td></tr><tr><td><tt class="literal">"foo"</tt></td><td>&nbsp;</td><td>1(base)</td><td>-4</td></tr></tbody></table></div><p>
				In this case, the function <tt class="literal">ps_gettop</tt> would return 4;
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3933"></a>Stack manipulation</h3></div></div><div></div></div><p>The API offers several functions to push and retrieve data from the Pscript stack.</p><p>
				To push a value that is already present in the stack in the top position
				</p><pre class="programlisting">void ps_push(HPSCRIPTVM v,PSInteger idx);</pre><p>
			</p><p>
				To pop an arbitrary number of elements
				</p><pre class="programlisting">void ps_pop(HPSCRIPTVM v,PSInteger nelemstopop);</pre><p>
			</p><p>
				To remove an element from the stack
				</p><pre class="programlisting">void ps_remove(HPSCRIPTVM v,PSInteger idx);</pre><p>
			</p><p>
				To retrieve the top index (and size) of the current 
				virtual stack you must call <tt class="literal">ps_gettop</tt>
				</p><pre class="programlisting">PSInteger ps_gettop(HPSCRIPTVM v);</pre><p>
			</p><p>
				To force the stack to a certain size you can call <tt class="literal">ps_settop</tt>
				</p><pre class="programlisting">void ps_settop(HPSCRIPTVM v,PSInteger newtop);</pre><p>
			</p><p>
				If the newtop is bigger than the previous one, the new posistions in the stack will be
				filled with null values.
			</p><p>The following function pushes a C value into the stack</p><pre class="programlisting">
void ps_pushstring(HPSCRIPTVM v,const PSChar *s,PSInteger len);
void ps_pushfloat(HPSCRIPTVM v,PSFloat f);
void ps_pushinteger(HPSCRIPTVM v,PSInteger n);
void ps_pushuserpointer(HPSCRIPTVM v,PSUserPointer p);
void ps_pushbool(HPSCRIPTVM v,PSBool b);
			</pre><p>
				this function pushes a null into the stack
				</p><pre class="programlisting">void ps_pushnull(HPSCRIPTVM v);</pre><p>
			</p><p>
				returns the type of the value in a arbitrary position in the stack
				</p><pre class="programlisting">PSObjectType ps_gettype(HPSCRIPTVM v,PSInteger idx);</pre><p>
			</p><p>
				the result can be one of the following values:
				</p><pre class="programlisting">
OT_NULL,OT_INTEGER,OT_FLOAT,OT_STRING,OT_TABLE,OT_ARRAY,OT_USERDATA,
OT_CLOSURE,OT_NATIVECLOSURE,OT_GENERATOR,OT_USERPOINTER,OT_BOOL,OT_INSTANCE,OT_CLASS,OT_WEAKREF
				</pre><p>
			</p><p>The following functions convert a pscript value in the stack to a C value</p><pre class="programlisting">
PSRESULT ps_getstring(HPSCRIPTVM v,PSInteger idx,const PSChar **c);
PSRESULT ps_getinteger(HPSCRIPTVM v,PSInteger idx,PSInteger *i);
PSRESULT ps_getfloat(HPSCRIPTVM v,PSInteger idx,PSFloat *f);
PSRESULT ps_getuserpointer(HPSCRIPTVM v,PSInteger idx,PSUserPointer *p);
PSRESULT ps_getuserdata(HPSCRIPTVM v,PSInteger idx,PSUserPointer *p,PSUserPointer *typetag);
PSRESULT ps_getbool(HPSCRIPTVM v,PSInteger idx,PSBool *p);
			</pre><p>
				The function ps_cmp compares 2 values from the stack and returns their relation (like
				strcmp() in ANSI C).
				</p><pre class="programlisting">PSInteger ps_cmp(HPSCRIPTVM v);</pre><p>
			</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4000"></a>Runtime error handling</h2></div></div><div></div></div><p>
			When an exception is not handled by Pscript code with a try/catch statement, a runtime
			error is raised and the execution of the current program is interrupted. It is possible to
			set a call back function to intercept the runtime error from the host program; this is
			useful to show meaningful errors to the script writer and for implementing visual
			debuggers.
			The following API call pops a Pscript function from the stack and sets it as error handler.
			</p><pre class="programlisting">PSCRIPT_API void ps_seterrorhandler(HPSCRIPTVM v);</pre><p>
		</p><p>
			The error handler is called with 2 parameters, an environment object (this) and a object.
			The object can be any pscript type.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4011"></a>Compiling a script</h2></div></div><div></div></div><p>You can compile a Pscript script with the function <tt class="literal">ps_compile</tt>.</p><pre class="programlisting">
typedef PSInteger (*PSLEXREADFUNC)(PSUserPointer userdata);

PSRESULT ps_compile(HPSCRIPTVM v,PSREADFUNC read,PSUserPointer p,
	const PSChar *sourcename,PSBool raiseerror);
		</pre><p>
			In order to compile a script is necessary for the host application to implement a reader
			function (PSLEXREADFUNC); this function is used to feed the compiler with the script
			data.
			The function is called every time the compiler needs a character; It has to return a
			character code if succeed or 0 if the source is finished.
		</p><p>
			If ps_compile succeeds, the compiled script will be pushed as Pscript function in the
			stack.
			</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
				In order to execute the script, the function generated by <tt class="literal">ps_compile()</tt> has 
				to be called through <tt class="literal">ps_call()</tt></div><p>
		</p><p>
			Here an example of a &#8216;read&#8217; function that read from a file:
		</p><pre class="programlisting">
PSInteger file_lexfeedASCII(PSUserPointer file)
{
    int ret;
    char c;
    if( ( ret=fread(&amp;c,sizeof(c),1,(FILE *)file )&gt;0) )
        return c;
    return 0;
}

int compile_file(HPSCRIPTVM v,const char *filename)
{
    FILE *f=fopen(filename,&#8221;rb&#8221;);
    if(f)
    {
         ps_compile(v,file_lexfeedASCII,f,filename,1);
         fclose(f);
         return 1;
    }
    return 0;
}
		</pre><p>
			When the compiler fails for a syntax error it will try to call the &#8216;compiler error handler&#8217;;
			this function must be declared as follow
		</p><pre class="programlisting">
typedef void (*PSCOMPILERERROR)(HPSCRIPTVM /*v*/,const PSChar * /*desc*/,const PSChar *
/*source*/,PSInteger /*line*/,PSInteger /*column*/);
		</pre><p>and can be set with the following API call</p><pre class="programlisting">void ps_setcompilererrorhandler(HPSCRIPTVM v,PSCOMPILERERROR f);</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4046"></a>Calling a function</h2></div></div><div></div></div><p>
			To call a pscript function it is necessary to push the function in the stack followed by the
			parameters and then call the function ps_call.
			The function will pop the parameters and push the return value if the last ps_call
			parameter is &gt;0.
		</p><pre class="programlisting">
ps_pushroottable(v);
ps_pushstring(v,&#8220;foo&#8221;,-1);
ps_get(v,-2); //get the function from the root table
ps_pushroottable(v); //&#8217;this&#8217; (function environment object)
ps_pushinteger(v,1);
ps_pushfloat(v,2.0);
ps_pushstring(v,&#8221;three&#8221;,-1);
ps_call(v,4,PSFalse);
ps_pop(v,2); //pops the roottable and the function
		</pre><p>this is equivalent to the following Pscript code</p><pre class="programlisting">foo(1,2.0,&#8221;three&#8221;);</pre><p>
			If a runtime error occurs (or a exception is thrown) during the pscript code execution
			the ps_call will fail.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4060"></a>Create a C function</h2></div></div><div></div></div><p>A native C function must have the following prototype:</p><pre class="programlisting">typedef PSInteger (*PSFUNCTION)(HPSCRIPTVM);</pre><p>
			The parameters is an handle to the calling VM and the return value is an integer
			respecting the following rules:
		</p><div class="itemizedlist"><ul type="disc"><li><p>1 if the function returns a value</p></li><li><p>0 if the function does not return a value</p></li><li><p>PS_ERROR runtime error is thrown</p></li></ul></div><p>
			In order to obtain a new callable pscript function from a C function pointer, is necessary
			to call ps_newclosure() passing the C function to it; the new Pscript function will be
			pushed in the stack.
		</p><p>
			When the function is called, the stackbase is the first parameter of the function and the
			top is the last. In order to return a value the function has to push it in the stack and
			return 1.
		</p><p>
      Function parameters are in the stack from postion 1 ('this') to <tt class="literal">n</tt>.
      <tt class="literal">ps_gettop()</tt> can be used to determinate the number of parameters.
    </p><p>
      If the function has free variables, those will be in the stack after the explicit parameters
      an can be handled as normal parameters. Note also that the value returned by<tt class="literal">ps_gettop()</tt> will be
      affected by free variables. <tt class="literal">ps_gettop()</tt> will return the number of parameters plus
      number of free variables.
    </p><p>
			Here an example, the following function print the value of each argument and return the
			number of arguments.
		</p><pre class="programlisting">
                  
PSInteger print_args(HPSCRIPTVM v)
{
    PSInteger nargs = ps_gettop(v); //number of arguments
    for(PSInteger n=1;n&lt;=nargs;n++)
    {
        printf("arg %d is ",n);
        switch(ps_gettype(v,n))
        {
            case OT_NULL:
                printf("null");        
                break;
            case OT_INTEGER:
                printf("integer");
                break;
            case OT_FLOAT:
                printf("float");
                break;
            case OT_STRING:
                printf("string");
                break;    
            case OT_TABLE:
                printf("table");
                break;
            case OT_ARRAY:
                printf("array");
                break;
            case OT_USERDATA:
                printf("userdata");
                break;
            case OT_CLOSURE:        
                printf("closure(function)");    
                break;
            case OT_NATIVECLOSURE:
                printf("native closure(C function)");
                break;
            case OT_GENERATOR:
                printf("generator");
                break;
            case OT_USERPOINTER:
                printf("userpointer");
                break;
            case OT_CLASS:
                printf("class");
                break;
            case OT_INSTANCE:
                printf("instance");
                break;
            case OT_WEAKREF:
                printf("weak reference");
                break;
            default:
                return ps_throwerror(v,"invalid param"); //throws an exception
        }
    }
    printf("\n");
    ps_pushinteger(v,nargs); //push the number of arguments as return value
    return 1; //1 because 1 value is returned
}
		</pre><p>Here an example of how to register a function</p><pre class="programlisting">
PSInteger register_global_func(HPSCRIPTVM v,PSFUNCTION f,const char *fname)
{
    ps_pushroottable(v);
    ps_pushstring(v,fname,-1);
    ps_newclosure(v,f,0,0); //create a new function
    ps_newslot(v,-3,PSFalse); 
    ps_pop(v,1); //pops the root table    
}
		</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4108"></a>Tables and arrays manipulation</h2></div></div><div></div></div><p>
				A new table is created calling ps_newtable, this function pushes a new table in the stack.
				</p><pre class="programlisting">void ps_newtable (HPSCRIPTVM v);</pre><p>
			</p><p>
				To create a new slot
				</p><pre class="programlisting">PSRESULT ps_newslot(HPSCRIPTVM v,PSInteger idx,PSBool bstatic);</pre><p>
			</p><p>
				To set or get the table delegate
				</p><pre class="programlisting">
PSRESULT ps_setdelegate(HPSCRIPTVM v,PSInteger idx);
PSRESULT ps_getdelegate(HPSCRIPTVM v,PSInteger idx);
				</pre><p>
			</p><p>
				A new array is created calling ps_newarray, the function pushes a new array in the
				stack; if the parameters size is bigger than 0 the elements are initialized to null.
				</p><pre class="programlisting">void ps_newarray (HPSCRIPTVM v,PSInteger size);</pre><p>
			</p><p>
				To append a value to the back of the array
				</p><pre class="programlisting">PSRESULT ps_arrayappend(HPSCRIPTVM v,PSInteger idx);</pre><p>
			</p><p>
				To remove a value from the back of the array
				</p><pre class="programlisting">PSRESULT ps_arraypop(HPSCRIPTVM v,PSInteger idx,PSInteger pushval);</pre><p>
			</p><p>
				To resize the array
				</p><pre class="programlisting">PSRESULT ps_arrayresize(HPSCRIPTVM v,PSInteger idx,PSInteger newsize);</pre><p>
			</p><p>
				To retrieve the size of a table or an array you must use ps_getsize()
				</p><pre class="programlisting">PSInteger ps_getsize(HPSCRIPTVM v,PSInteger idx);</pre><p>
			</p><p>
				To set a value in an array or table
				</p><pre class="programlisting">PSRESULT ps_set(HPSCRIPTVM v,PSInteger idx);</pre><p>
			</p><p>
				To get a value from an array or table
				</p><pre class="programlisting">PSRESULT ps_get(HPSCRIPTVM v,PSInteger idx);</pre><p>
			</p><p>
				To get or set a value from a table without employ delegation
				</p><pre class="programlisting">
PSRESULT ps_rawget(HPSCRIPTVM v,PSInteger idx);
PSRESULT ps_rawset(HPSCRIPTVM v,PSInteger idx);
				</pre><p>
			</p><p>
				To iterate a table or an array
				</p><pre class="programlisting">PSRESULT ps_next(HPSCRIPTVM v,PSInteger idx);</pre><p>
			</p><p>
				Here an example of how to perform an iteration:
				</p><pre class="programlisting">
//push your table/array here
ps_pushnull(v)  //null iterator
while(PS_SUCCEEDED(ps_next(v,-2)))
{
    //here -1 is the value and -2 is the key
    
    ps_pop(v,2); //pops key and val before the nex iteration
}

ps_pop(v,1); //pops the null iterator
				</pre><p>
			</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4177"></a>Userdata and UserPointers</h2></div></div><div></div></div><a name="userdandup"></a><p>
				Pscript allows the host application put arbitrary data chunks into a Pscript value, this is
				possible through the data type userdata.
				</p><pre class="programlisting">PSUserPointer ps_newuserdata (HPSCRIPTVM v,PSUnsignedInteger size);</pre><p>
			</p><p>
				When the function <tt class="literal">ps_newuserdata</tt> is called, Pscript allocates a new userdata with the
				specified size, returns a pointer to his payload buffer and push the object in the stack; at
				this point the application can do whatever it want with this memory chunk, the VM will
				automatically take cake of the memory deallocation like for every other built-in type.
				A userdata can be passed to a function or stored in a table slot. By default Pscript
				cannot manipulate directly userdata; however is possible to assign a delegate to it and
				define a behavior like it would be a table.
				Because the application would want to do something with the data stored in a userdata
				object when it get deleted, is possible to assign a callback that will be called by the VM
				just before deleting a certain userdata.
				This is done through the API call <tt class="literal">ps_setreleasehook</tt>.
			</p><pre class="programlisting">
typedef PSInteger (*PSRELEASEHOOK)(PSUserPointer,PSInteger size);

void ps_setreleasehook(HPSCRIPTVM v,PSInteger idx,PSRELEASEHOOK hook);
			</pre><p>
				Another kind of userdata is the userpointer; this type is not a memory chunk like the
				normal userdata, but just a &#8216;void*&#8217; pointer. It cannot have a delegate and is passed by
				value, so pushing a userpointer doesn&#8217;t cause any memory allocation.
			</p><pre class="programlisting">void ps_pushuserpointer(HPSCRIPTVM v,PSUserPointer p);</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4201"></a>The registry table</h2></div></div><div></div></div><p>
				The registry table is an hidden table shared between vm and all his thread(friend vms).
				This table is accessible only through the C API and is ment to be an utility structure
				for native C library implementation.
				For instance the psstdlib(pscript standard library)uses it to store configuration and shared objects
				delegates.
				The registry is accessible through the API call <tt class="function">ps_pushregistrytable</tt>.
				</p><pre class="programlisting">void ps_pushregistrytable(HPSCRIPTVM v);</pre><p>
			</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4213"></a>Mantaining strong references to Pscript values from the C API</h2></div></div><div></div></div><p>
          Pscript allows to reference values through the C API; the function ps_getstackobj() gets
          a handle to a pscript object(any type). The object handle can be used to control the lifetime
          of an object by adding or removing references to it( see ps_addref() and ps_release()).
          The object can be also re-pushed in the VM stack using ps_pushobject().
        </p><pre class="programlisting">
HPSOBJECT obj;

ps_resetobject(v,&amp;obj) //initialize the handle
ps_getstackobj(v,-2,&amp;obj); //retrieve an object handle from the pos &#8211;2
ps_addref(v,&amp;obj); //adds a reference to the object

&#8230; //do stuff

ps_pushobject(v,&amp;obj); //push the object in the stack
ps_release(v,&amp;obj); //relese the object
				</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4221"></a>Debug Interface</h2></div></div><div></div></div><p>
        The pscript VM exposes a very simple debug interface that allows to easily built a full
        featured debugger.
        Through the functions ps_setdebughook and ps_setnativedebughook is possible in fact to set a callback function that
        will be called every time the VM executes an new line of a script or if a function get
        called/returns. The callback will pass as argument the current line the current source and the
        current function name (if any).
        </p><pre class="programlisting">PSCRIPT_API void ps_setdebughook(HPSCRIPTVM v);</pre><p>
        or
        </p><pre class="programlisting">PSCRIPT_API void ps_setnativedebughook(HPSCRIPTVM v,PSDEBUGHOOK hook);</pre><p>
			</p><p>
				The following code shows how a debug hook could look like(obviously is possible to
				implement this function in C as well).
			</p><pre class="programlisting">
function debughook(event_type,sourcefile,line,funcname)
{
    local fname=funcname?funcname:"unknown";
    local srcfile=sourcefile?sourcefile:"unknown"
    switch (event_type) {
    case 'l': //called every line(that contains some code)
        ::print("LINE line [" + line + "] func [" + fname + "]");
        ::print("file [" + srcfile + "]\n");
		break;
    case 'c': //called when a function has been called
        ::print("LINE line [" + line + "] func [" + fname + "]");
        ::print("file [" + srcfile + "]\n");
		break;
    case 'r': //called when a function returns
        ::print("LINE line [" + line + "] func [" + fname + "]");
        ::print("file [" + srcfile + "]\n");
		break;
	}
}
			</pre><p>
			The parameter <tt class="literal">event_type</tt> can be 'l' ,'c' or 'r' ; a hook with a 'l' event is called for each line that
			gets executed, 'c' every time a function gets called and 'r' every time a function returns.
			</p><p>
				A full-featured debugger always allows displaying local variables and calls stack.
				The call stack information are retrieved through ps_getstackinfos()
				</p><pre class="programlisting">PSInteger ps_stackinfos(HPSCRIPTVM v,PSInteger level,PSStackInfos *si);</pre><p>
			</p><p>
				While the local variables info through ps_getlocal()
				</p><pre class="programlisting">PSInteger ps_getlocal(HPSCRIPTVM v,PSUnsignedInteger level,PSUnsignedInteger nseq);</pre><p>
			</p><p>
				In order to receive line callbacks the scripts have to be compiled with debug infos enabled
				this is done through ps_enabledebuginfo();
				</p><pre class="programlisting">void ps_enabledebuginfo(HPSCRIPTVM v, PSInteger debuginfo);</pre><p>
			</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e4257"></a>Chapter&nbsp;4.&nbsp;API Reference</h2></div></div><div></div></div><div class="reference" lang="en"><a name="d0e4260"></a><div class="titlepage"><div><div><h1 class="title"><a name="d0e4260"></a>Virtual Machine</h1></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#ps_close">ps_close</a> - </dt><dt><a href="#ps_geterrorfunc">ps_geterrorfunc</a> - </dt><dt><a href="#ps_getforeignptr">ps_getforeignptr</a> - </dt><dt><a href="#ps_getprintfunc">ps_getprintfunc</a> - </dt><dt><a href="#ps_getversion">ps_getversion</a> - </dt><dt><a href="#ps_getvmstate">ps_getvmstate</a> - </dt><dt><a href="#ps_move">ps_move</a> - </dt><dt><a href="#ps_newthread">ps_newthread</a> - </dt><dt><a href="#ps_open">ps_open</a> - </dt><dt><a href="#ps_pushconsttable">ps_pushconsttable</a> - </dt><dt><a href="#ps_pushregistrytable">ps_pushregistrytable</a> - </dt><dt><a href="#ps_pushroottable">ps_pushroottable</a> - </dt><dt><a href="#ps_setconsttable">ps_setconsttable</a> - </dt><dt><a href="#ps_seterrorhandler">ps_seterrorhandler</a> - </dt><dt><a href="#ps_setforeignptr">ps_setforeignptr</a> - </dt><dt><a href="#ps_setprintfunc">ps_setprintfunc</a> - </dt><dt><a href="#ps_setroottable">ps_setroottable</a> - </dt><dt><a href="#ps_suspendvm">ps_suspendvm</a> - </dt><dt><a href="#ps_wakeupvm">ps_wakeupvm</a> - </dt></dl></div><div class="refentry" lang="en"><a name="ps_close"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_close<a class="indexterm" name="d0e4274"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_close</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var><code>)</code>;</p></div><p>
				releases a pscript VM and all related friend VMs
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd></dl></div></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_geterrorfunc"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_geterrorfunc<a class="indexterm" name="d0e4312"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSPRINTFUNCTION&nbsp;<b class="fsfunc">ps_geterrorfunc</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var><code>)</code>;</p></div><p>
        returns the current error function of the given Virtual machine.
        (see ps_setprintfunc())
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
        the target VM
      </p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
        a pointer to a PSPRINTFUNCTION, or NULL if no function has been set.
      <br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_getforeignptr"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_getforeignptr<a class="indexterm" name="d0e4357"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSUserPointer&nbsp;<b class="fsfunc">ps_getforeignptr</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var><code>)</code>;</p></div><p>
				Returns the foreign pointer of a VM instance.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				the current VMs foreign pointer.
			<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_getprintfunc"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_getprintfunc<a class="indexterm" name="d0e4402"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSPRINTFUNCTION&nbsp;<b class="fsfunc">ps_getprintfunc</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var><code>)</code>;</p></div><p>
				returns the current print function of the given Virtual machine.
				(see ps_setprintfunc())
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
			a pointer to a PSPRINTFUNCTION, or NULL if no function has been set.
			<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_getversion"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_getversion<a class="indexterm" name="d0e4447"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSInteger&nbsp;<b class="fsfunc">ps_getversion</b>(</code><code>)</code>;</p></div><p>
        returns the version number of the vm.
      </p><div class="variablelist"><dl><dt><span class="term">return:</span></dt><dd><p>
        version number of the vm(as in PSCRIPT_VERSION_NUMBER).
      <br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_getvmstate"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_getvmstate<a class="indexterm" name="d0e4478"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSInteger&nbsp;<b class="fsfunc">ps_getvmstate</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var><code>)</code>;</p></div><p>
				returns the execution state of a virtual machine
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				the state of the vm encoded as integer value.
				The following constants are defined: PS_VMSTATE_IDLE, PS_VMSTATE_RUNNING, PS_VMSTATE_SUSPENDED.
			<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_move"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_move<a class="indexterm" name="d0e4523"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_move</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;dest</var>, <var class="pdparam">HPSCRIPTVM&nbsp;src</var>, <var class="pdparam">PSInteger&nbsp;idx</var><code>)</code>;</p></div><p>
				pushes the object at the position 'idx' of the source vm stack in the
				destination vm stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;dest</tt></i></span></dt><dd><p>
				the destination VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;src</tt></i></span></dt><dd><p>
				the source VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				the index in the source stack of the value that has to be moved
			</p></dd></dl></div></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_newthread"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_newthread<a class="indexterm" name="d0e4579"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">HPSCRIPTVM&nbsp;<b class="fsfunc">ps_newthread</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;friendvm</var>, <var class="pdparam">PSInteger&nbsp;initialstacksize</var><code>)</code>;</p></div><p>
				creates a new vm friendvm of the one passed 
				as first parmeter and pushes it in its stack
				as "thread" object.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;friendvm</tt></i></span></dt><dd><p>
				a friend VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;initialstacksize</tt></i></span></dt><dd><p>
				the size of the stack in slots(number of objects)
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a pointer to the new VM.
			<br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
				By default the roottable is shared with the VM passed
				as first parameter.
				The new VM lifetime is bound to the "thread" object pushed
				in the stack and behave like a normal pscript object.
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_open"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_open<a class="indexterm" name="d0e4639"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">HPSCRIPTVM&nbsp;<b class="fsfunc">ps_open</b>(</code><var class="pdparam">PSInteger&nbsp;initialstacksize</var><code>)</code>;</p></div><p>
				creates a new instance of a pscript VM that consists in a new execution stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;initialstacksize</tt></i></span></dt><dd><p>
				the size of the stack in slots(number of objects)
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				an handle to a pscript vm
			<br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
				the returned VM has to be released with ps_releasevm
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_pushconsttable"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_pushconsttable<a class="indexterm" name="d0e4690"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_pushconsttable</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var><code>)</code>;</p></div><p>
        pushes the current const table in the stack
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
        the target VM
      </p></dd></dl></div></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_pushregistrytable"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_pushregistrytable<a class="indexterm" name="d0e4728"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_pushregistrytable</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var><code>)</code>;</p></div><p>
				pushes the registry table in the stack
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd></dl></div></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_pushroottable"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_pushroottable<a class="indexterm" name="d0e4766"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_pushroottable</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var><code>)</code>;</p></div><p>
				pushes the current root table in the stack
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd></dl></div></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_setconsttable"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_setconsttable<a class="indexterm" name="d0e4804"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_setconsttable</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var><code>)</code>;</p></div><p>
        pops a table from the stack and set it as const table
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
        the target VM
      </p></dd></dl></div></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_seterrorhandler"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_seterrorhandler<a class="indexterm" name="d0e4842"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_seterrorhandler</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var><code>)</code>;</p></div><p>
				pops from the stack a closure or native closure an sets it as runtime-error handler.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd></dl></div></dd><dt><span class="term">remarks:</span></dt><dd><p>
				the error handler is shared by friend VMs
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_setforeignptr"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_setforeignptr<a class="indexterm" name="d0e4886"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_setforeignptr</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSUserPointer&nbsp;p</var><code>)</code>;</p></div><p>
				Sets the foreign pointer of a certain VM instance. The foreign pointer is an arbitrary
				user defined pointer associated to a VM (by default is value id 0). This pointer is
				ignored by the VM.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSUserPointer&nbsp;p</tt></i></span></dt><dd><p>
				The pointer that has to be set
			</p></dd></dl></div></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_setprintfunc"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_setprintfunc<a class="indexterm" name="d0e4933"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_setprintfunc</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSPRINTFUNCTION&nbsp;printfunc</var>, <var class="pdparam">PSPRINTFUNCTION&nbsp;errorfunc</var><code>)</code>;</p></div><p>
				sets the print function of the virtual machine.
				This function is used by the built-in function '::print()'
				to output text.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSPRINTFUNCTION&nbsp;printfunc</tt></i></span></dt><dd><p>
				a pointer to the print func or NULL to disable the
				output.
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSPRINTFUNCTION&nbsp;errorfunc</tt></i></span></dt><dd><p>
        a pointer to the error func or NULL to disable the
        output.
      </p></dd></dl></div></dd><dt><span class="term">remarks:</span></dt><dd><p>
			the print func has the following prototype:
			void printfunc(HPSCRIPTVM v,const PSChar *s,...)
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_setroottable"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_setroottable<a class="indexterm" name="d0e4995"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_setroottable</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var><code>)</code>;</p></div><p>
				pops a table from the stack and set it as root table
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd></dl></div></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_suspendvm"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_suspendvm<a class="indexterm" name="d0e5033"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">HRESULT&nbsp;<b class="fsfunc">ps_suspendvm</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var><code>)</code>;</p></div><p>
				Suspends the execution of the specified vm.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				an PSRESULT(that has to be returned by a C function)
			<br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
				ps_result can only be called as return expression of a C function.
				The function will fail is the suspension is done through
				more C calls or in a metamethod.
			</p></dd><dt><span class="term">eg.</span></dt><dd><pre class="programlisting">
PSInteger suspend_vm_example(HPSCRIPTVM v)
{
	return ps_suspendvm(v);
}
				</pre></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_wakeupvm"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_wakeupvm<a class="indexterm" name="d0e5091"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">HRESULT&nbsp;<b class="fsfunc">ps_wakeupvm</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSBool&nbsp;resumedret</var>, <var class="pdparam">PSBool&nbsp;retval</var>, <var class="pdparam">PSBool&nbsp;raiseerror</var>, <var class="pdparam">PSBool&nbsp;throwerror</var><code>)</code>;</p></div><p>
        Wake up the execution a previously suspended virtual machine.
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
        the target VM
      </p></dd><dt><span class="term"><i class="parameter"><tt>PSBool&nbsp;resumedret</tt></i></span></dt><dd><p>
        if true the function will pop a value from the stack
        and use it as return value for the function that has previously
        suspended the virtual machine.
      </p></dd><dt><span class="term"><i class="parameter"><tt>PSBool&nbsp;retval</tt></i></span></dt><dd><p>
        if true the function will push the return value of the function
        that suspend the excution or the main function one.
      </p></dd><dt><span class="term"><i class="parameter"><tt>PSBool&nbsp;raiseerror</tt></i></span></dt><dd><p>
        if true, if a runtime error occurs during the execution of the call,
        the vm will invoke the error handler.
      </p></dd><dt><span class="term"><i class="parameter"><tt>PSBool&nbsp;throwerror</tt></i></span></dt><dd><p>
        if true, the vm will thow an exception as soon as is resumed. the exception
        payload must be set beforehand invoking ps_thowerror().
      </p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
        an HRESULT.
      <br></p></dd></dl></div></div></div><div class="reference" lang="en"><a name="d0e5161"></a><div class="titlepage"><div><div><h1 class="title"><a name="d0e5161"></a>Compiler</h1></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#ps_compile">ps_compile</a> - </dt><dt><a href="#ps_compilebuffer">ps_compilebuffer</a> - </dt><dt><a href="#ps_enabledebuginfo">ps_enabledebuginfo</a> - </dt><dt><a href="#ps_notifyallexceptions">ps_notifyallexceptions</a> - </dt><dt><a href="#ps_setcompilererrorhandler">ps_setcompilererrorhandler</a> - </dt></dl></div><div class="refentry" lang="en"><a name="ps_compile"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_compile<a class="indexterm" name="d0e5175"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_compile</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">HPSLEXREADFUNC&nbsp;read</var>, <var class="pdparam">PSUserPointer&nbsp;p</var>, <var class="pdparam">const PSChar *&nbsp;sourcename</var>, <var class="pdparam">PSBool&nbsp;raiseerror</var><code>)</code>;</p></div><p>
				compiles a pscript program; if it succeeds, push the compiled script as function in
				the stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>HPSLEXREADFUNC&nbsp;read</tt></i></span></dt><dd><p>
				a pointer to a read function that will feed the compiler with the program.
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSUserPointer&nbsp;p</tt></i></span></dt><dd><p>
				a user defined pointer that will be passed by the compiler to the read function at
				each invocation.
			</p></dd><dt><span class="term"><i class="parameter"><tt>const PSChar *&nbsp;sourcename</tt></i></span></dt><dd><p>
				the symbolic name of the program (used only for more meaningful runtime
				errors)
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSBool&nbsp;raiseerror</tt></i></span></dt><dd><p>
				if this value is true the compiler error handler will be called in case of an
				error
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT. If the ps_compile fails nothing is pushed in the
				stack.
			<br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
				in case of an error the function will call the function set by
				ps_setcompilererrorhandler().
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_compilebuffer"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_compilebuffer<a class="indexterm" name="d0e5262"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_compilebuffer</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">const PSChar*&nbsp;s</var>, <var class="pdparam">PSInteger&nbsp;size</var>, <var class="pdparam">const PSChar *&nbsp;sourcename</var>, <var class="pdparam">PSBool&nbsp;raiseerror</var><code>)</code>;</p></div><p>
				compiles a pscript program from a memory buffer; if it succeeds, push the compiled script as function in
				the stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>const PSChar*&nbsp;s</tt></i></span></dt><dd><p>
				a pointer to the buffer that has to be compiled.
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;size</tt></i></span></dt><dd><p>
				size in characters of the buffer passed in the parameter 's'.
			</p></dd><dt><span class="term"><i class="parameter"><tt>const PSChar *&nbsp;sourcename</tt></i></span></dt><dd><p>
				the symbolic name of the program (used only for more meaningful runtime
				errors)
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSBool&nbsp;raiseerror</tt></i></span></dt><dd><p>
				if this value true the compiler error handler will be called in case of an
				error
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT. If the ps_compilebuffer fails nothing is pushed in the
				stack.
			<br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
				in case of an error the function will call the function set by
				ps_setcompilererrorhandler().
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_enabledebuginfo"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_enabledebuginfo<a class="indexterm" name="d0e5349"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_enabledebuginfo</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSBool&nbsp;enable</var><code>)</code>;</p></div><p>
				enable/disable the debug line information generation at compile time.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSBool&nbsp;enable</tt></i></span></dt><dd><p>
				if true enables the debug info generation, if == 0 disables it.
			</p></dd></dl></div></dd><dt><span class="term">remarks:</span></dt><dd><p>
				The function affects all threads as well.
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_notifyallexceptions"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_notifyallexceptions<a class="indexterm" name="d0e5402"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_notifyallexceptions</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSBool&nbsp;enable</var><code>)</code>;</p></div><p>
        enable/disable the error callback notification of handled exceptions.
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
        the target VM
      </p></dd><dt><span class="term"><i class="parameter"><tt>PSBool&nbsp;enable</tt></i></span></dt><dd><p>
        if true enables the error callback notification of handled exceptions.
      </p></dd></dl></div></dd><dt><span class="term">remarks:</span></dt><dd><p>
        By default the VM will invoke the error callback only if an exception is
        not handled (no try/catch traps are present in the call stack).
        If notifyallexceptions is enabled, the VM will call the error callback for 
        any exception even if between try/catch blocks. This feature is useful
        for implementing debuggers.
      </p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_setcompilererrorhandler"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_setcompilererrorhandler<a class="indexterm" name="d0e5455"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_setcompilererrorhandler</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSCOMPILERERROR&nbsp;f</var><code>)</code>;</p></div><p>
				sets the compiler error handler function
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSCOMPILERERROR&nbsp;f</tt></i></span></dt><dd><p>
				A pointer to the error handler function
			</p></dd></dl></div></dd><dt><span class="term">remarks:</span></dt><dd><p>
				if the parameter f is NULL no function will be called when a compiler error occurs.
				The compiler error handler is shared between friend VMs.
			</p></dd></dl></div></div></div><div class="reference" lang="en"><a name="d0e5497"></a><div class="titlepage"><div><div><h1 class="title"><a name="d0e5497"></a>Stack Operations</h1></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#ps_cmp">ps_cmp</a> - </dt><dt><a href="#ps_gettop">ps_gettop</a> - </dt><dt><a href="#ps_pop">ps_pop</a> - </dt><dt><a href="#ps_poptop">ps_poptop</a> - </dt><dt><a href="#ps_push">ps_push</a> - </dt><dt><a href="#ps_remove">ps_remove</a> - </dt><dt><a href="#ps_reservestack">ps_reservestack</a> - </dt><dt><a href="#ps_settop">ps_settop</a> - </dt></dl></div><div class="refentry" lang="en"><a name="ps_cmp"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_cmp<a class="indexterm" name="d0e5511"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSInteger&nbsp;<b class="fsfunc">ps_cmp</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var><code>)</code>;</p></div><p>
				compares 2 object from the stack and compares them.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>&gt; 0 if obj1&gt;obj2<br>== 0 if obj1==obj2<br>&lt; 0 if obj1&lt;obj2<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_gettop"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_gettop<a class="indexterm" name="d0e5560"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSInteger&nbsp;<b class="fsfunc">ps_gettop</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var><code>)</code>;</p></div><p>
				returns the index of the top of the stack
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				an integer representing the index of the top of the stack
			<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_pop"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_pop<a class="indexterm" name="d0e5605"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_pop</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;nelementstopop</var><code>)</code>;</p></div><p>
				pops n elements from the stack
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;nelementstopop</tt></i></span></dt><dd><p>
				the number of elements to pop
			</p></dd></dl></div></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_poptop"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_poptop<a class="indexterm" name="d0e5652"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_poptop</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var><code>)</code>;</p></div><p>
				pops 1 object from the stack
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd></dl></div></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_push"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_push<a class="indexterm" name="d0e5690"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_push</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var><code>)</code>;</p></div><p>
        pushes in the stack the value at the index idx
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
        the target VM
      </p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
        the index in the stack of the value that has to be pushed
      </p></dd></dl></div></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_remove"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_remove<a class="indexterm" name="d0e5737"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_remove</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var><code>)</code>;</p></div><p>
				removes an element from an arbitrary position in the stack
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				index of the element that has to be removed
			</p></dd></dl></div></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_reservestack"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_reservestack<a class="indexterm" name="d0e5784"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_reservestack</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;nsize</var><code>)</code>;</p></div><p>
        ensure that the stack space left is at least of a specified size.If the stack
        is smaller it will automatically grow.
        if there's a memtamethod currently running the function will fail and the stack will not be resized,
        this situatuation has to be considered a "stack overflow".
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;nsize</tt></i></span></dt><dd><p>
				required stack size
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
        a PSRESULT
      <br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_settop"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_settop<a class="indexterm" name="d0e5838"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_settop</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;v</var><code>)</code>;</p></div><p>
				resize the stack, if new top is bigger then the current top the function will push nulls.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;v</tt></i></span></dt><dd><p>
				the new top index
			</p></dd></dl></div></dd></dl></div></div></div><div class="reference" lang="en"><a name="d0e5874"></a><div class="titlepage"><div><div><h1 class="title"><a name="d0e5874"></a>Object creation and handling</h1></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#ps_bindenv">ps_bindenv</a> - </dt><dt><a href="#ps_createinstance">ps_createinstance</a> - </dt><dt><a href="#ps_getbool">ps_getbool</a> - </dt><dt><a href="#ps_getbyhandle">ps_getbyhandle</a> - </dt><dt><a href="#ps_getclosureinfo">ps_getclosureinfo</a> - </dt><dt><a href="#ps_getclosurename">ps_getclosurename</a> - </dt><dt><a href="#ps_getfloat">ps_getfloat</a> - </dt><dt><a href="#ps_gethash">ps_gethash</a> - </dt><dt><a href="#ps_getinstanceup">ps_getinstanceup</a> - </dt><dt><a href="#ps_getinteger">ps_getinteger</a> - </dt><dt><a href="#ps_getmemberhandle">ps_getmemberhandle</a> - </dt><dt><a href="#ps_getscratchpad">ps_getscratchpad</a> - </dt><dt><a href="#ps_getsize">ps_getsize</a> - </dt><dt><a href="#ps_getstring">ps_getstring</a> - </dt><dt><a href="#ps_getthread">ps_getthread</a> - </dt><dt><a href="#ps_gettype">ps_gettype</a> - </dt><dt><a href="#ps_gettypetag">ps_gettypetag</a> - </dt><dt><a href="#ps_getuserdata">ps_getuserdata</a> - </dt><dt><a href="#ps_getuserpointer">ps_getuserpointer</a> - </dt><dt><a href="#ps_newarray">ps_newarray</a> - </dt><dt><a href="#ps_newclass">ps_newclass</a> - </dt><dt><a href="#ps_newclosure">ps_newclosure</a> - </dt><dt><a href="#ps_newtable">ps_newtable</a> - </dt><dt><a href="#ps_newtableex">ps_newtableex</a> - </dt><dt><a href="#ps_newuserdata">ps_newuserdata</a> - </dt><dt><a href="#ps_pushbool">ps_pushbool</a> - </dt><dt><a href="#ps_pushfloat">ps_pushfloat</a> - </dt><dt><a href="#ps_pushinteger">ps_pushinteger</a> - </dt><dt><a href="#ps_pushnull">ps_pushnull</a> - </dt><dt><a href="#ps_pushstring">ps_pushstring</a> - </dt><dt><a href="#ps_pushuserpointer">ps_pushuserpointer</a> - </dt><dt><a href="#ps_setbyhandle">ps_setbyhandle</a> - </dt><dt><a href="#ps_setclassudsize">ps_setclassudsize</a> - </dt><dt><a href="#ps_setinstanceup">ps_setinstanceup</a> - </dt><dt><a href="#ps_setnativeclosurename">ps_setnativeclosurename</a> - </dt><dt><a href="#ps_setparamscheck">ps_setparamscheck</a> - </dt><dt><a href="#ps_setreleasehook">ps_setreleasehook</a> - </dt><dt><a href="#ps_settypetag">ps_settypetag</a> - </dt><dt><a href="#ps_tobool">ps_tobool</a> - </dt><dt><a href="#ps_tostring">ps_tostring</a> - </dt><dt><a href="#ps_typeof">ps_typeof</a> - </dt></dl></div><div class="refentry" lang="en"><a name="ps_bindenv"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_bindenv<a class="indexterm" name="d0e5888"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_bindenv</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var><code>)</code>;</p></div><p>
        pops an object from the stack(must be a table,instance or class) clones the closure at position
        idx in the stack and sets the popped object as environment of the cloned closure.
        Then pushes the new cloned closure on top of the stack.
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
        the target VM
      </p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
        index of the target closure
      </p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
        a PSRESULT
      <br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
        the cloned closure holds the environment object as weak reference
      </p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_createinstance"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_createinstance<a class="indexterm" name="d0e5948"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_createinstance</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var><code>)</code>;</p></div><p>
				creates an instance of the class at 'idx' position in the stack. The new class instance
				is pushed on top of the stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				index of the target class
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
				the function doesn't invoke the instance contructor. To create an instance and automatically
				invoke its contructor, ps_call must be used instead.
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_getbool"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_getbool<a class="indexterm" name="d0e6008"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_getbool</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var>, <var class="pdparam">PSBool *&nbsp;b</var><code>)</code>;</p></div><p>
				gets the value of the bool at the idx position in the stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				an index in the stack
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSBool *&nbsp;b</tt></i></span></dt><dd><p>
				A pointer to the bool that will store the value
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_getbyhandle"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_getbyhandle<a class="indexterm" name="d0e6071"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_getbyhandle</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var>, <var class="pdparam">HPSMEMBERHANDLE*&nbsp;handle</var><code>)</code>;</p></div><p>
        pushes the value of a class or instance member using a member handle (see ps_getmemberhandle)
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
        the target VM
      </p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
        an index in the stack pointing to the class
      </p></dd><dt><span class="term"><i class="parameter"><tt>HPSMEMBERHANDLE*&nbsp;handle</tt></i></span></dt><dd><p>
        a pointer the member handle
      </p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>a PSRESULT<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_getclosureinfo"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_getclosureinfo<a class="indexterm" name="d0e6134"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_getclosureinfo</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var>, <var class="pdparam">PSUnsignedInteger *&nbsp;nparams</var>, <var class="pdparam">PSUnsignedInteger *&nbsp;nfreevars</var><code>)</code>;</p></div><p>
				retrieves number of parameters and number of freevariables from a pscript closure.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				index of the target closure
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSUnsignedInteger *&nbsp;nparams</tt></i></span></dt><dd><p>
				a pointer to an unsigned integer that will store the number of parameters
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSUnsignedInteger *&nbsp;nfreevars</tt></i></span></dt><dd><p>
				a pointer to an unsigned integer that will store the number of free variables
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				an PSRESULT
			<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_getclosurename"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_getclosurename<a class="indexterm" name="d0e6206"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_getclosurename</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var><code>)</code>;</p></div><p>
        pushes the name of the closure at poistion idx in the stack. Note that the name can be a string or null 
        if the closure is anonymous or a native closure with no name assigned to it.
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
        the target VM
      </p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
        index of the target closure
      </p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
        an PSRESULT
      <br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_getfloat"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_getfloat<a class="indexterm" name="d0e6260"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_getfloat</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var>, <var class="pdparam">PSFloat *&nbsp;f</var><code>)</code>;</p></div><p>
				gets the value of the float at the idx position in the stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				an index in the stack
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSFloat *&nbsp;f</tt></i></span></dt><dd><p>
				A pointer to the float that will store the value
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_gethash"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_gethash<a class="indexterm" name="d0e6323"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSHash&nbsp;<b class="fsfunc">ps_gethash</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var><code>)</code>;</p></div><p>
        returns the hash key of a value at the idx position in the stack.
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
        the target VM
      </p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
        an index in the stack
      </p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
        the hash key of the value at the position idx in the stack
      <br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
        the hash value function is the same used by the VM.
      </p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_getinstanceup"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_getinstanceup<a class="indexterm" name="d0e6383"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_getinstanceup</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var>, <var class="pdparam">PSUserPointer *&nbsp;up</var>, <var class="pdparam">PSUSerPointer&nbsp;typetag</var><code>)</code>;</p></div><p>
				gets the userpointer of the class instance at position idx in the stack.
				if the parameter 'typetag' is different than 0, the function checks that the class or a base
				class of the instance is tagged with the specified tag; if not the function fails.
				If 'typetag' is 0 the function will ignore the tag check.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				an index in the stack
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSUserPointer *&nbsp;up</tt></i></span></dt><dd><p>
				a pointer to the userpointer that will store the result
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSUSerPointer&nbsp;typetag</tt></i></span></dt><dd><p>
				the typetag that has to be checked, if this value is set to 0 the typetag is ignored.
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_getinteger"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_getinteger<a class="indexterm" name="d0e6455"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_getinteger</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var>, <var class="pdparam">PSInteger *&nbsp;i</var><code>)</code>;</p></div><p>
				gets the value of the integer at the idx position in the stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				an index in the stack
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger *&nbsp;i</tt></i></span></dt><dd><p>
				A pointer to the integer that will store the value
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_getmemberhandle"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_getmemberhandle<a class="indexterm" name="d0e6518"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_getmemberhandle</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var>, <var class="pdparam">HPSMEMBERHANDLE*&nbsp;handle</var><code>)</code>;</p></div><p>
        pops a value from the stack and uses it as index to fetch the handle of a class member.
        The handle can be later used to set or get the member value using ps_getbyhandle(),ps_setbyhandle().
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
        the target VM
      </p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
        an index in the stack pointing to the class
      </p></dd><dt><span class="term"><i class="parameter"><tt>HPSMEMBERHANDLE*&nbsp;handle</tt></i></span></dt><dd><p>
        a pointer to the variable that will store the handle
      </p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>a PSRESULT<br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
        This method works only with classes and instances. 
        A handle retrieved through a class can be later used to set or get values from one of the class instances and vice-versa.
        Handles retrieved from base classes are still valid in derived classes and respect inheritance rules.
      </p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_getscratchpad"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_getscratchpad<a class="indexterm" name="d0e6587"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSChar *&nbsp;<b class="fsfunc">ps_getscratchpad</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;minsize</var><code>)</code>;</p></div><p>
				returns a pointer to a memory buffer that is at least as big as minsize.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;minsize</tt></i></span></dt><dd><p>
				the requested size for the scratchpad buffer
			</p></dd></dl></div></dd><dt><span class="term">remarks:</span></dt><dd><p>
				the buffer is valid until the next call to ps_getscratchpad
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_getsize"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_getsize<a class="indexterm" name="d0e6640"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSObjectType&nbsp;<b class="fsfunc">ps_getsize</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var><code>)</code>;</p></div><p>
        returns the size of a value at the idx position in the stack, if the value is a class or a class instance
        the size returned is the size of the userdata buffer(see ps_setclassudsize).
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
        the target VM
      </p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
        an index in the stack
      </p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
        the size of the value at the position idx in the stack
      <br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
        this function only works with strings,arrays,tables,classes,instances and userdata if the value is not a valid type
        types the function will return &#8211;1.
      </p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_getstring"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_getstring<a class="indexterm" name="d0e6700"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_getstring</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var>, <var class="pdparam">const PSChar **&nbsp;c</var><code>)</code>;</p></div><p>
				gets a pointer to the string at the idx position in the stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				an index in the stack
			</p></dd><dt><span class="term"><i class="parameter"><tt>const PSChar **&nbsp;c</tt></i></span></dt><dd><p>
				a pointer to the pointer that will point to the string
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_getthread"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_getthread<a class="indexterm" name="d0e6763"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_getthread</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var>, <var class="pdparam">HPSCRIPTVM*&nbsp;v</var><code>)</code>;</p></div><p>
				gets a a pointer to the thread the idx position in the stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				an index in the stack
			</p></dd><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM*&nbsp;v</tt></i></span></dt><dd><p>
				A pointer to the variable that will store the thread pointer
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_gettype"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_gettype<a class="indexterm" name="d0e6826"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSObjectType&nbsp;<b class="fsfunc">ps_gettype</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var><code>)</code>;</p></div><p>
				returns the type of the value at the position idx in the stack
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				an index in the stack
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
			the type of the value at the position idx in the stack
			<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_gettypetag"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_gettypetag<a class="indexterm" name="d0e6880"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_gettypetag</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var>, <var class="pdparam">PSUserPointer *&nbsp;typetag</var><code>)</code>;</p></div><p>
				gets the typetag of the object(userdata or class) at position idx in the stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				an index in the stack
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSUserPointer *&nbsp;typetag</tt></i></span></dt><dd><p>
				a pointer to the variable that will store the tag
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
				the function works also with instances. if the taget object is an instance,
				the typetag of it's base class is fetched.
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_getuserdata"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_getuserdata<a class="indexterm" name="d0e6949"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_getuserdata</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var>, <var class="pdparam">PSUserPointer *&nbsp;p</var>, <var class="pdparam">PSUserPointer *&nbsp;typetag</var><code>)</code>;</p></div><p>
				gets a pointer to the value of the userdata at the idx position in the stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				an index in the stack
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSUserPointer *&nbsp;p</tt></i></span></dt><dd><p>
				A pointer to the userpointer that will point to the userdata's payload
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSUserPointer *&nbsp;typetag</tt></i></span></dt><dd><p>
				A pointer to a PSUserPointer that will store the userdata tag(see ps_settypetag).
				The parameter can be NULL.
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_getuserpointer"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_getuserpointer<a class="indexterm" name="d0e7021"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_getuserpointer</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var>, <var class="pdparam">PSUserPointer *&nbsp;p</var><code>)</code>;</p></div><p>
				gets the value of the userpointer at the idx position in the stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				an index in the stack
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSUserPointer *&nbsp;p</tt></i></span></dt><dd><p>
				A pointer to the userpointer that will store the value
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_newarray"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_newarray<a class="indexterm" name="d0e7084"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_newarray</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;size</var><code>)</code>;</p></div><p>
				creates a new array and pushes it in the stack
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;size</tt></i></span></dt><dd><p>
				the size of the array that as to be created
			</p></dd></dl></div></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_newclass"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_newclass<a class="indexterm" name="d0e7131"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_newclass</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSBool&nbsp;hasbase</var><code>)</code>;</p></div><p>
				creates a new class object. If the parameter 'hasbase' is different than 0,
				the function pops a class from the stack and inherits the new created class from it.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSBool&nbsp;hasbase</tt></i></span></dt><dd><p>
				if the parameter is true the function expects
				a base class on top of the stack.
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_newclosure"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_newclosure<a class="indexterm" name="d0e7185"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_newclosure</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">HPSFUNCTION&nbsp;func</var>, <var class="pdparam">PSInteger&nbsp;nfreevars</var><code>)</code>;</p></div><p>
				create a new native closure, pops n values set those as free variables of the new
				closure, and push the new closure in the stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>HPSFUNCTION&nbsp;func</tt></i></span></dt><dd><p>
				a pointer to a native-function
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;nfreevars</tt></i></span></dt><dd><p>
				number of free variables(can be 0)
			</p></dd></dl></div></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_newtable"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_newtable<a class="indexterm" name="d0e7241"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_newtable</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var><code>)</code>;</p></div><p>
				creates a new table and pushes it in the stack
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd></dl></div></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_newtableex"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_newtableex<a class="indexterm" name="d0e7279"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_newtableex</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;initialcapacity</var><code>)</code>;</p></div><p>
        creates a new table and pushes it in the stack. 
        This function allows to specify the initial capacity of the table to prevent unnecessary rehashing
        when the number of slots required is known at creation-time.
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
        the target VM
      </p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;initialcapacity</tt></i></span></dt><dd><p>
        number of key/value pairs to preallocate
      </p></dd></dl></div></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_newuserdata"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_newuserdata<a class="indexterm" name="d0e7326"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSUserPointer&nbsp;<b class="fsfunc">ps_newuserdata</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSUnsignedInteger&nbsp;size</var><code>)</code>;</p></div><p>
				creates a new userdata and pushes it in the stack
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSUnsignedInteger&nbsp;size</tt></i></span></dt><dd><p>
				the size of the userdata that as to be created in bytes
			</p></dd></dl></div></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_pushbool"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_pushbool<a class="indexterm" name="d0e7373"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_pushbool</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSBool&nbsp;b</var><code>)</code>;</p></div><p>
				pushes a bool into the stack
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSBool&nbsp;b</tt></i></span></dt><dd><p>
				the bool that has to be pushed(PSTrue or PSFalse)
			</p></dd></dl></div></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_pushfloat"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_pushfloat<a class="indexterm" name="d0e7420"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_pushfloat</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSFloat&nbsp;f</var><code>)</code>;</p></div><p>
				pushes a float into the stack
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSFloat&nbsp;f</tt></i></span></dt><dd><p>
				the float that has to be pushed
			</p></dd></dl></div></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_pushinteger"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_pushinteger<a class="indexterm" name="d0e7467"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_pushinteger</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;n</var><code>)</code>;</p></div><p>
				pushes a integer into the stack
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;n</tt></i></span></dt><dd><p>
				the integer that has to be pushed
			</p></dd></dl></div></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_pushnull"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_pushnull<a class="indexterm" name="d0e7514"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_pushnull</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var><code>)</code>;</p></div><p>
				pushes a null value into the stack
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd></dl></div></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_pushstring"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_pushstring<a class="indexterm" name="d0e7552"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_pushstring</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">const PSChar *&nbsp;s</var>, <var class="pdparam">PSInteger&nbsp;len</var><code>)</code>;</p></div><p>
				pushes a string in the stack
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>const PSChar *&nbsp;s</tt></i></span></dt><dd><p>
				pointer to the string that has to be pushed
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;len</tt></i></span></dt><dd><p>
				lenght of the string pointed by s
			</p></dd></dl></div></dd><dt><span class="term">remarks:</span></dt><dd><p>
				if the parameter len is less than 0 the VM will calculate the length using strlen(s)
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_pushuserpointer"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_pushuserpointer<a class="indexterm" name="d0e7614"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_pushuserpointer</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSUserPointer&nbsp;p</var><code>)</code>;</p></div><p>
				pushes a userpointer into the stack
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSUserPointer&nbsp;p</tt></i></span></dt><dd><p>
				the pointer that as to be pushed
			</p></dd></dl></div></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_setbyhandle"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_setbyhandle<a class="indexterm" name="d0e7661"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_setbyhandle</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var>, <var class="pdparam">HPSMEMBERHANDLE*&nbsp;handle</var><code>)</code>;</p></div><p>
        pops a value from the stack and sets it to a class or instance member using a member handle (see ps_getmemberhandle)
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
        the target VM
      </p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
        an index in the stack pointing to the class
      </p></dd><dt><span class="term"><i class="parameter"><tt>HPSMEMBERHANDLE*&nbsp;handle</tt></i></span></dt><dd><p>
        a pointer the member handle
      </p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>a PSRESULT<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_setclassudsize"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_setclassudsize<a class="indexterm" name="d0e7724"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_setclassudsize</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var>, <var class="pdparam">PSInteger&nbsp;udsize</var><code>)</code>;</p></div><p>
        Sets the user data size of a class.
        If a class 'user data size' is greater than 0. When an instance of the class is created
        additional space will is reserved at the end of the memory chunk where the instance is stored. 
        The userpointer of the instance will also be automatically set to this memory area.
        This allows to minimize allocations in applications that have to carry data along with the class instance.
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
        the target VM
      </p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
        an index in the stack pointing to the class
      </p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;udsize</tt></i></span></dt><dd><p>
        size in bytes reserved for user data
      </p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
        a PSRESULT
      <br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_setinstanceup"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_setinstanceup<a class="indexterm" name="d0e7787"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_setinstanceup</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var>, <var class="pdparam">PSUserPointer&nbsp;up</var><code>)</code>;</p></div><p>
				sets the userpointer of the class instance at position idx in the stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				an index in the stack
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSUserPointer&nbsp;up</tt></i></span></dt><dd><p>
				an arbitrary user pointer
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_setnativeclosurename"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_setnativeclosurename<a class="indexterm" name="d0e7850"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_setnativeclosurename</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var>, <var class="pdparam">const PSChar *&nbsp;name</var><code>)</code>;</p></div><p>
				sets the name of the native closure at the position idx in the stack.
				the name of a native closure is purely for debug pourposes. The name is retieved
				trough the function ps_stackinfos() while the closure is in the call stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				index of the target native closure
			</p></dd><dt><span class="term"><i class="parameter"><tt>const PSChar *&nbsp;name</tt></i></span></dt><dd><p>
				the name that has to be set
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				an PSRESULT
			<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_setparamscheck"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_setparamscheck<a class="indexterm" name="d0e7913"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_setparamscheck</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;nparamscheck</var>, <var class="pdparam">const PSChar *&nbsp;typemask</var><code>)</code>;</p></div><p>
				Sets the parameters validation scheme for the native closure at
				the top position in the stack.
				Allows to validate the number of paramters accepted by the function
				and optionally their types. If the function call do not comply with
				the parameter schema set by ps_setparamscheck, an exception is thrown.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;nparamscheck</tt></i></span></dt><dd><p>
				defines the parameters number check policy(0 disable the param checking).
				if nparamscheck is greater than 0 the VM ensures that the number of parameters is exactly the
				number specified in nparamscheck(eg. if nparamscheck == 3 the function can only be called with 3 parameters).
				if nparamscheck is less than 0 the VM ensures that the closure is called with at least the absolute value
				of the number specified in nparamcheck(eg. nparamscheck == -3 will check that the function is called with at least 3 parameters).
				the hidden paramater 'this' is included in this number free variables aren't.
				If PS_MATCHTYPEMASKSTRING is passed instead of the number of parameters, the function will automatically extrapolate
				the number of parameters to check from the typemask(eg. if the typemask is ".sn" is like passing 3).
			</p></dd><dt><span class="term"><i class="parameter"><tt>const PSChar *&nbsp;typemask</tt></i></span></dt><dd><p>
				defines a mask to validate the parametes types passed to the function.
				if the parameter is NULL no typechecking is applyed(default).
			</p></dd></dl></div></dd><dt><span class="term">remarks:</span></dt><dd><p>
				The typemask consists in a zero teminated string that represent the expected parameter type.
				The types are expressed as follows: 'o' null, 'i' integer, 'f' float, 'n' integer or float, 's' string, 't' table,
				'a' array, 'u' userdata, 'c' closure and nativeclosure, 'g' generator, 'p' userpointer, 'v' thread, 'x' instance(class instance),
				'y' class, 'b' bool.
				and '.' any type. The symbol '|' can be used as 'or' to accept multiple types on the same parameter.
				There isn't any limit on the number of 'or' that can be used. Spaces are ignored so can be inserted between types
				to increase readbility.
				For instance to check a function that espect a table as 'this' a string as first parameter and
				a number or a userpointer as second parameter, the string would be "tsn|p" (table,string,number or userpointer).
				If the parameters mask is contains less parameters than 'nparamscheck' the remaining parameters will
				not be typechecked.
			</p></dd><dt><span class="term">eg.</span></dt><dd><pre class="programlisting">
//example
PSInteger testy(HPSCRIPTVM v)
{
	PSUserPointer p;
	const PSChar *s;
	PSInteger i;
	//no type checking, if the call comply to the mask 
	//surely the functions will succeed.
	ps_getuserdata(v,1,&amp;p,NULL);
	ps_getstring(v,2,&amp;s);
	ps_getinteger(v,3,&amp;i);
	//... do something
	return 0;
}

//the reg code

//....stuff
ps_newclosure(v,testy,0);
//expects exactly 3 parameters(userdata,string,number)
ps_setparamscheck(v,3,_SC("usn")); 
//....stuff
			</pre></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_setreleasehook"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_setreleasehook<a class="indexterm" name="d0e7982"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_setreleasehook</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var>, <var class="pdparam">PSRELEASEHOOK&nbsp;hook</var><code>)</code>;</p></div><p>
        sets the release hook of the userdata, class instance or class at position idx in the stack.
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				an index in the stack
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSRELEASEHOOK&nbsp;hook</tt></i></span></dt><dd><p>
				a function pointer to the hook(see sample below)
			</p></dd></dl></div></dd><dt><span class="term">remarks:</span></dt><dd><p>
				the function hook is called by the VM before the userdata memory is deleted.
			</p></dd><dt><span class="term">eg.</span></dt><dd><pre class="programlisting">

/* tyedef PSInteger (*PSRELEASEHOOK)(PSUserPointer,PSInteger size); */

PSInteger my_release_hook(PSUserPointer p,PSInteger size)
{
	/* do something here */
	return 1;
}
				</pre></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_settypetag"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_settypetag<a class="indexterm" name="d0e8051"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_settypetag</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var>, <var class="pdparam">PSUserPointer&nbsp;typetag</var><code>)</code>;</p></div><p>
				sets the typetag of the object(userdata or class) at position idx in the stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				an index in the stack
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSUserPointer&nbsp;typetag</tt></i></span></dt><dd><p>
				an arbitrary PSUserPointer
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_tobool"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_tobool<a class="indexterm" name="d0e8114"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_tobool</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var>, <var class="pdparam">PSBool *&nbsp;b</var><code>)</code>;</p></div><p>
        gets the value at position idx in the stack as bool. 
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
        the target VM
      </p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
        an index in the stack
      </p></dd><dt><span class="term"><i class="parameter"><tt>PSBool *&nbsp;b</tt></i></span></dt><dd><p>
        A pointer to the bool that will store the value
      </p></dd></dl></div></dd><dt><span class="term">remarks:</span></dt><dd><p>
        if the object is not a bool the function converts the value too bool 
        according to pscript's rules.
        For instance the number 1 will result in true, and the number 0 in false.
      </p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_tostring"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_tostring<a class="indexterm" name="d0e8176"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_tostring</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var><code>)</code>;</p></div><p>
        converts the object at position idx in the stack to string and pushes the
        resulting string in the stack.
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
        the target VM
      </p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
        an index in the stack
      </p></dd></dl></div></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_typeof"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_typeof<a class="indexterm" name="d0e8223"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSObjectType&nbsp;<b class="fsfunc">ps_typeof</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var><code>)</code>;</p></div><p>
        pushes the type name of the value at the position idx in the stack, 
        it also invokes the _typeof metamethod for tables and class instances that implement it;
        in that case the pushed object could be something other than a string (is up to the _typeof implementation).
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
        the target VM
      </p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
        an index in the stack
      </p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
        a PSRESULT
      <br></p></dd></dl></div></div></div><div class="reference" lang="en"><a name="d0e8266"></a><div class="titlepage"><div><div><h1 class="title"><a name="d0e8266"></a>Calls</h1></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#ps_call">ps_call</a> - </dt><dt><a href="#ps_getcallee">ps_getcallee</a> - </dt><dt><a href="#ps_getlasterror">ps_getlasterror</a> - </dt><dt><a href="#ps_getlocal">ps_getlocal</a> - </dt><dt><a href="#ps_reseterror">ps_reseterror</a> - </dt><dt><a href="#ps_resume">ps_resume</a> - </dt><dt><a href="#ps_throwerror">ps_throwerror</a> - </dt><dt><a href="#ps_throwobject">ps_throwobject</a> - </dt></dl></div><div class="refentry" lang="en"><a name="ps_call"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_call<a class="indexterm" name="d0e8280"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_call</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;params</var>, <var class="pdparam">PSBool&nbsp;retval</var>, <var class="pdparam">PSBool&nbsp;raiseerror</var><code>)</code>;</p></div><p>
				calls a closure or a native closure.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;params</tt></i></span></dt><dd><p>
				number of parameters of the function
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSBool&nbsp;retval</tt></i></span></dt><dd><p>
				if true the function will push the return value in the stack
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSBool&nbsp;raiseerror</tt></i></span></dt><dd><p>
        if true, if a runtime error occurs during the execution of the call,
        the vm will invoke the error handler.
      </p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
				the function pops all the parameters and leave the closure in the stack; 
				if retval is true the return value of the closure is pushed.
				If the execution of the function is suspended through ps_suspendvm(), the closure
				and the arguments will not be automatically popped from the stack.
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_getcallee"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_getcallee<a class="indexterm" name="d0e8358"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_getcallee</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var><code>)</code>;</p></div><p>
        push in the stack the currently running closure.
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
        the target VM
      </p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
        a PSRESULT
      <br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_getlasterror"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_getlasterror<a class="indexterm" name="d0e8403"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_getlasterror</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var><code>)</code>;</p></div><p>
				pushes the last error in the stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
				the pushed error descriptor can be any valid pscript type.
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_getlocal"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_getlocal<a class="indexterm" name="d0e8454"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">const PSChar *&nbsp;<b class="fsfunc">ps_getlocal</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSUnsignedInteger&nbsp;level</var>, <var class="pdparam">PSUnsignedInteger&nbsp;nseq</var><code>)</code>;</p></div><p>
				Returns the name of a local variable given stackframe and sequence in the stack and
				pushes is current value.
        Free variables are treated as local variables, by ps_getlocal(), and will be returned 
        as they would be at the base of the stack, just before the real local variables.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSUnsignedInteger&nbsp;level</tt></i></span></dt><dd><p>
				the function index in the calls stack, 0 is the current function
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSUnsignedInteger&nbsp;nseq</tt></i></span></dt><dd><p>
				the index of the local variable in the stack frame (0 is &#8216;this&#8217;)
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				the name of the local variable if a variable exists at the given level/seq otherwise NULL.
			<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_reseterror"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_reseterror<a class="indexterm" name="d0e8517"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_reseterror</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var><code>)</code>;</p></div><p>
				reset the last error in the virtual machine to null
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd></dl></div></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_resume"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_resume<a class="indexterm" name="d0e8555"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_resume</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSBool&nbsp;retval</var>, <var class="pdparam">PSBool&nbsp;raiseerror</var><code>)</code>;</p></div><p>
				resumes the generator at the top position of the stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSBool&nbsp;retval</tt></i></span></dt><dd><p>
				if true the function will push the return value in the stack
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSBool&nbsp;raiseerror</tt></i></span></dt><dd><p>
        if true, if a runtime error occurs during the execution of the call, 
        the vm will invoke the error handler.
      </p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
				if retval != 0 the return value of the generator is pushed.
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_throwerror"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_throwerror<a class="indexterm" name="d0e8624"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_throwerror</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">const PSChar *&nbsp;err</var><code>)</code>;</p></div><p>
				sets the last error in the virtual machine and returns the value that has to be
				returned by a native closure in order to trigger an exception in the virtual machine.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>const PSChar *&nbsp;err</tt></i></span></dt><dd><p>
				the description of the error that has to be thrown
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				the value that has to be returned by a native closure in order to throw an exception in
				the virtual machine.
			<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_throwobject"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_throwobject<a class="indexterm" name="d0e8678"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_throwobject</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var><code>)</code>;</p></div><p>
        pops a value from the stack sets it as the last error in the virtual machine. Returns the value that has to be
        returned by a native closure in order to trigger an exception in the virtual machine (aka PS_ERROR).
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
        the target VM
      </p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
        the value that has to be returned by a native closure in order to throw an exception in
        the virtual machine.
      <br></p></dd></dl></div></div></div><div class="reference" lang="en"><a name="d0e8712"></a><div class="titlepage"><div><div><h1 class="title"><a name="d0e8712"></a>Objects manipulation</h1></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#ps_arrayappend">ps_arrayappend</a> - </dt><dt><a href="#ps_arrayinsert">ps_arrayinsert</a> - </dt><dt><a href="#ps_arraypop">ps_arraypop</a> - </dt><dt><a href="#ps_arrayremove">ps_arrayremove</a> - </dt><dt><a href="#ps_arrayresize">ps_arrayresize</a> - </dt><dt><a href="#ps_arrayreverse">ps_arrayreverse</a> - </dt><dt><a href="#ps_clear">ps_clear</a> - </dt><dt><a href="#ps_clone">ps_clone</a> - </dt><dt><a href="#ps_createslot">ps_createslot</a> - </dt><dt><a href="#ps_deleteslot">ps_deleteslot</a> - </dt><dt><a href="#ps_get">ps_get</a> - </dt><dt><a href="#ps_getattributes">ps_getattributes</a> - </dt><dt><a href="#ps_getclass">ps_getclass</a> - </dt><dt><a href="#ps_getdelegate">ps_getdelegate</a> - </dt><dt><a href="#ps_getfreevariable">ps_getfreevariable</a> - </dt><dt><a href="#ps_getweakrefval">ps_getweakrefval</a> - </dt><dt><a href="#ps_instanceof">ps_instanceof</a> - </dt><dt><a href="#ps_newmember">ps_newmember</a> - </dt><dt><a href="#ps_newslot">ps_newslot</a> - </dt><dt><a href="#ps_next">ps_next</a> - </dt><dt><a href="#ps_rawdeleteslot">ps_rawdeleteslot</a> - </dt><dt><a href="#ps_rawget">ps_rawget</a> - </dt><dt><a href="#ps_rawnewmember">ps_rawnewmember</a> - </dt><dt><a href="#ps_rawset">ps_rawset</a> - </dt><dt><a href="#ps_set">ps_set</a> - </dt><dt><a href="#ps_setattributes">ps_setattributes</a> - </dt><dt><a href="#ps_setdelegate">ps_setdelegate</a> - </dt><dt><a href="#ps_setfreevariable">ps_setfreevariable</a> - </dt><dt><a href="#ps_weakref">ps_weakref</a> - </dt></dl></div><div class="refentry" lang="en"><a name="ps_arrayappend"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_arrayappend<a class="indexterm" name="d0e8726"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_arrayappend</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var><code>)</code>;</p></div><p>
				pops a value from the stack and pushes it in the back of the array at the position idx
				in the stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				index of the target array in the stack
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
				Only works on arrays.
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_arrayinsert"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_arrayinsert<a class="indexterm" name="d0e8786"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_arrayinsert</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var>, <var class="pdparam">PSInteger&nbsp;destpos</var><code>)</code>;</p></div><p>
        pops a value from the stack and inserts it in an array at the specified position
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
        the target VM
      </p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
        index of the target array in the stack
      </p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;destpos</tt></i></span></dt><dd><p>
        the postion in the array where the item has to be inserted
      </p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
        a PSRESULT
      <br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
        Only works on arrays.
      </p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_arraypop"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_arraypop<a class="indexterm" name="d0e8855"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_arraypop</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var><code>)</code>;</p></div><p>
				pops a value from the back of the array at the position idx in the stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				index of the target array in the stack
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
				Only works on arrays.
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_arrayremove"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_arrayremove<a class="indexterm" name="d0e8915"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_arrayremove</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var>, <var class="pdparam">PSInteger&nbsp;itemidx</var><code>)</code>;</p></div><p>
        removes an item from an array
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
        the target VM
      </p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
        index of the target array in the stack
      </p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;itemidx</tt></i></span></dt><dd><p>
        the index of the item in the array that has to be removed
      </p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
        a PSRESULT
      <br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
        Only works on arrays.
      </p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_arrayresize"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_arrayresize<a class="indexterm" name="d0e8984"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_arrayresize</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var>, <var class="pdparam">PSInteger&nbsp;newsize</var><code>)</code>;</p></div><p>
				resizes the array at the position idx in the stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				index of the target array in the stack
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;newsize</tt></i></span></dt><dd><p>
				requested size of the array
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
				Only works on arrays.if newsize if greater than the current size
				the new array slots will be filled with nulls.
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_arrayreverse"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_arrayreverse<a class="indexterm" name="d0e9053"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_arrayreverse</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var><code>)</code>;</p></div><p>
				reverse an array in place.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				index of the target array in the stack
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
				Only works on arrays.
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_clear"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_clear<a class="indexterm" name="d0e9113"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_clear</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var><code>)</code>;</p></div><p>
        clears all the element of the table/array at position idx in the stack.
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
        the target VM
      </p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
        index of the target object in the stack
      </p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
        a PSRESULT
      <br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
        Only works on tables and arrays.
      </p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_clone"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_clone<a class="indexterm" name="d0e9173"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_clone</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var><code>)</code>;</p></div><p>
				Clones the table, array or class instance at the position idx, clones it and pushes the new object in
				the stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				index of the target object in the stack
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_createslot"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_createslot<a class="indexterm" name="d0e9227"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_createslot</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var><code>)</code>;</p></div><p>
				pops a key and a value from the stack and performs a set operation on the table or class that is at
				position idx in the stack, if the slot does not exits it will be created.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				index of the target table in the stack
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
				invoke the _newslot metamethod in the table delegate. it only works on tables.
				[this function is deperecated since version 2.0.5 use ps_newslot() instead]
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_deleteslot"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_deleteslot<a class="indexterm" name="d0e9287"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_deleteslot</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var>, <var class="pdparam">PSBool&nbsp;pushval</var><code>)</code>;</p></div><p>
				pops a key from the stack and delete the slot indexed by it from the table at
				position idx in the stack, if the slot does not exits nothing happens.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				index of the target table in the stack
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSBool&nbsp;pushval</tt></i></span></dt><dd><p>
				if this param is true the function will push the value
				of the deleted slot.
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
				invoke the _delslot metamethod in the table delegate. it only works on tables.
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_get"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_get<a class="indexterm" name="d0e9356"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_get</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var><code>)</code>;</p></div><p>
				pops a key from the stack and performs a get operation on the object at the position
				idx in the stack, and pushes the result in the stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				index of the target object in the stack
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
				this call will invokes the delegation system like a normal dereference it only works on
				tables, arrays and userdata. if the function fails nothing will be pushed in the stack.
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_getattributes"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_getattributes<a class="indexterm" name="d0e9416"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_getattributes</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var><code>)</code>;</p></div><p>
				Gets the attribute of a class mameber.
				The function pops a key from the stack and pushes the attribute of the class member indexed
				by they key from class at position idx in the stack.
				If key is null the function gets the class level attribute.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				index of the target class in the stack
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_getclass"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_getclass<a class="indexterm" name="d0e9470"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_getclass</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var><code>)</code>;</p></div><p>
				pushes the class of the 'class instance' at stored position idx in the stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				index of the target class instance in the stack
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_getdelegate"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_getdelegate<a class="indexterm" name="d0e9524"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_getdelegate</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var><code>)</code>;</p></div><p>
				pushes the current delegate of the object at the position idx in the stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				index of the target object in the stack
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_getfreevariable"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_getfreevariable<a class="indexterm" name="d0e9578"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">const PSChar *&nbsp;<b class="fsfunc">ps_getfreevariable</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var>, <var class="pdparam">PSInteger&nbsp;nval</var><code>)</code>;</p></div><p>
				gets the value of the free variable of the closure at the position
				idx in the stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				index of the target object in the stack(closure)
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;nval</tt></i></span></dt><dd><p>
				0 based index of the free variable(relative to the closure).
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				the name of the free variable for pure pscript closures. NULL in case of error or if the
				index of the variable is out of range.
        In case the target closure is a native closure, the return name is always "@NATIVE".
			<br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
				The function works for both pscript closure and native closure.
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_getweakrefval"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_getweakrefval<a class="indexterm" name="d0e9647"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_getweakrefval</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var><code>)</code>;</p></div><p>
				pushes the object pointed by the weak reference at position idx in the stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				index of the target weak reference
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
				if the function fails, nothing is pushed in the stack.
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_instanceof"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_instanceof<a class="indexterm" name="d0e9707"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSBool&nbsp;<b class="fsfunc">ps_instanceof</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var><code>)</code>;</p></div><p>
        Determintes if an object is an instance of a certain class.
        Expects an istance and a class in the stack.
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
        the target VM
      </p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
        PSTrue if the instance at position -2 in the stack is an instance of the class object at position -1 in the stack.
      <br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
        The function doesn't pop any object from the stack.
      </p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_newmember"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_newmember<a class="indexterm" name="d0e9758"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_newmember</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var>, <var class="pdparam">PSBool&nbsp;bstatic</var><code>)</code>;</p></div><p>
        pops a key, a value and an object(that will be set as attribute of the member) from the stack and performs a new slot operation on the class that is at
        position idx in the stack, if the slot does not exits it will be created.
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
        the target VM
      </p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
        index of the target table in the stack
      </p></dd><dt><span class="term"><i class="parameter"><tt>PSBool&nbsp;bstatic</tt></i></span></dt><dd><p>
        if PSTrue creates a static member.
      </p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
        a PSRESULT
      <br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
        Invokes the _newmember metamethod in the class. it only works on classes.
      </p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_newslot"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_newslot<a class="indexterm" name="d0e9827"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_newslot</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var>, <var class="pdparam">PSBool&nbsp;bstatic</var><code>)</code>;</p></div><p>
				pops a key and a value from the stack and performs a set operation on the table or class that is at
				position idx in the stack, if the slot does not exits it will be created.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				index of the target table in the stack
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSBool&nbsp;bstatic</tt></i></span></dt><dd><p>
				if PSTrue creates a static member. This parameter is only used if the target object
				is a class.
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
				Invokes the _newslot metamethod in the table delegate. it only works on tables and classes.
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_next"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_next<a class="indexterm" name="d0e9896"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_next</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var><code>)</code>;</p></div><p>
				Pushes in the stack the next key and value of an array, table or class slot.
				To start the iteration this function expects a null value on top of the stack; at every
				call the function will substitute the null value with an iterator and push key and value
				of the container slot. Every iteration the application has to pop the previous key and
				value but leave the iterator(that is used as reference point for the next iteration). The
				function will fail when all slots have been iterated(see Tables and arrays
				manipulation).
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				index of the target object in the stack
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_rawdeleteslot"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_rawdeleteslot<a class="indexterm" name="d0e9950"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_rawdeleteslot</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var>, <var class="pdparam">PSBool&nbsp;pushval</var><code>)</code>;</p></div><p>
				Deletes a slot from a table without employing the _delslot metamethod.
				pops a key from the stack and delete the slot indexed by it from the table at
				position idx in the stack, if the slot does not exits nothing happens.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				index of the target table in the stack
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSBool&nbsp;pushval</tt></i></span></dt><dd><p>
				if this param is true the function will push the value
				of the deleted slot.
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_rawget"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_rawget<a class="indexterm" name="d0e10013"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_rawget</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var><code>)</code>;</p></div><p>
				pops a key from the stack and performs a get operation on the object at position idx
				in the stack, without employing delegation or metamethods.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				index of the target object in the stack
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
				Only works on tables and arrays.
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_rawnewmember"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_rawnewmember<a class="indexterm" name="d0e10073"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_rawnewmember</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var>, <var class="pdparam">PSBool&nbsp;bstatic</var><code>)</code>;</p></div><p>
        pops a key, a value and an object(that will be set as attribute of the member) from the stack and performs a new slot operation on the class that is at
        position idx in the stack, if the slot does not exits it will be created.
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
        the target VM
      </p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
        index of the target table in the stack
      </p></dd><dt><span class="term"><i class="parameter"><tt>PSBool&nbsp;bstatic</tt></i></span></dt><dd><p>
        if PSTrue creates a static member.
      </p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
        a PSRESULT
      <br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
        it only works on classes.
      </p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_rawset"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_rawset<a class="indexterm" name="d0e10142"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_rawset</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var><code>)</code>;</p></div><p>
				pops a key and a value from the stack and performs a set operation on the object at
				position idx in the stack, without employing delegation or metamethods.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				index of the target object in the stack
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
				it only works on tables and arrays. if the function fails nothing will be pushed in the stack.
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_set"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_set<a class="indexterm" name="d0e10202"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_set</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var><code>)</code>;</p></div><p>
				pops a key and a value from the stack and performs a set operation on the object at
				position idx in the stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				index of the target object in the stack
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
				this call will invoke the delegation system like a normal assignment, it only works on
				tables, arrays and userdata.
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_setattributes"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_setattributes<a class="indexterm" name="d0e10262"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_setattributes</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var><code>)</code>;</p></div><p>
				Sets the attribute of a class mameber.
				The function pops a key and a value from the stack and sets the attribute (indexed
				by they key) on the class at position idx in the stack.
				If key is null the function sets the class level attribute.
				If the function succeed, the old attribute value is pushed in the stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				index of the target class in the stack.
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_setdelegate"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_setdelegate<a class="indexterm" name="d0e10316"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_setdelegate</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var><code>)</code>;</p></div><p>
				pops a table from the stack and sets it as delegate of the object at the position idx in
				the stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				index of the target object in the stack
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
				to remove the delgate from an object is necessary to use null as delegate instead of a table.
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_setfreevariable"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_setfreevariable<a class="indexterm" name="d0e10376"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_setfreevariable</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var>, <var class="pdparam">PSInteger&nbsp;nval</var><code>)</code>;</p></div><p>
				pops a value from the stack and sets it as free variable of the closure at the position
				idx in the stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				index of the target object in the stack
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;nval</tt></i></span></dt><dd><p>
				0 based index of the free variable(relative to the closure).
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_weakref"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_weakref<a class="indexterm" name="d0e10439"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_weakref</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var><code>)</code>;</p></div><p>
				pushes a weak reference to the object at position idx in the stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				index to the target object in the stack
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
				if the object at idx position is an integer,float,bool or null the object
				itself is pushed instead of a weak ref.
			</p></dd></dl></div></div></div><div class="reference" lang="en"><a name="d0e10488"></a><div class="titlepage"><div><div><h1 class="title"><a name="d0e10488"></a>Bytecode serialization</h1></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#ps_readclosure">ps_readclosure</a> - </dt><dt><a href="#ps_writeclosure">ps_writeclosure</a> - </dt></dl></div><div class="refentry" lang="en"><a name="ps_readclosure"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_readclosure<a class="indexterm" name="d0e10502"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_readclosure</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSREADFUNC&nbsp;readf</var>, <var class="pdparam">PSUserPointer&nbsp;up</var><code>)</code>;</p></div><p>
				serialize (read) a closure and pushes it on top of the stack, the source
				is user defined through a read callback.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSREADFUNC&nbsp;readf</tt></i></span></dt><dd><p>
				pointer to a read function that will be invoked by the vm during
				the serialization.
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSUserPointer&nbsp;up</tt></i></span></dt><dd><p>
				pointer that will be passed to each call to the read function
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_writeclosure"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_writeclosure<a class="indexterm" name="d0e10565"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_writeclosure</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSWRITEFUNC&nbsp;writef</var>, <var class="pdparam">PSUserPointer&nbsp;up</var><code>)</code>;</p></div><p>
				serialize(write) the closure on top of the stack, the desination
				is user defined through a write callback.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSWRITEFUNC&nbsp;writef</tt></i></span></dt><dd><p>
				pointer to a write function that will be invoked by the vm during
				the serialization.
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSUserPointer&nbsp;up</tt></i></span></dt><dd><p>
				pointer that will be passed to each call to the write function
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
				closures with free variables cannot be serialized
			</p></dd></dl></div></div></div><div class="reference" lang="en"><a name="d0e10623"></a><div class="titlepage"><div><div><h1 class="title"><a name="d0e10623"></a>Raw object handling</h1></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#ps_addref">ps_addref</a> - </dt><dt><a href="#ps_getobjtypetag">ps_getobjtypetag</a> - </dt><dt><a href="#ps_getrefcount">ps_getrefcount</a> - </dt><dt><a href="#ps_getstackobj">ps_getstackobj</a> - </dt><dt><a href="#ps_objtobool">ps_objtobool</a> - </dt><dt><a href="#ps_objtofloat">ps_objtofloat</a> - </dt><dt><a href="#ps_objtointeger">ps_objtointeger</a> - </dt><dt><a href="#ps_objtostring">ps_objtostring</a> - </dt><dt><a href="#ps_objtouserpointer">ps_objtouserpointer</a> - </dt><dt><a href="#ps_pushobject">ps_pushobject</a> - </dt><dt><a href="#ps_release">ps_release</a> - </dt><dt><a href="#ps_resetobject">ps_resetobject</a> - </dt></dl></div><div class="refentry" lang="en"><a name="ps_addref"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_addref<a class="indexterm" name="d0e10637"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_addref</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">HPSOBJECT *&nbsp;po</var><code>)</code>;</p></div><p>
				adds a reference to an object handler.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>HPSOBJECT *&nbsp;po</tt></i></span></dt><dd><p>
				pointer to an object handler
			</p></dd></dl></div></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_getobjtypetag"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_getobjtypetag<a class="indexterm" name="d0e10684"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_getobjtypetag</b>(</code><var class="pdparam">HPSOBJECT *&nbsp;o</var>, <var class="pdparam">PSUserPointer *&nbsp;typetag</var><code>)</code>;</p></div><p>
				gets the typetag of a raw object reference(userdata or class).
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSOBJECT *&nbsp;o</tt></i></span></dt><dd><p>
				pointer to an object handler
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSUserPointer *&nbsp;typetag</tt></i></span></dt><dd><p>
				a pointer to the variable that will store the tag
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
				the function works also with instances. if the taget object is an instance,
				the typetag of it's base class is fetched.
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_getrefcount"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_getrefcount<a class="indexterm" name="d0e10744"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSUnsignedInteger&nbsp;<b class="fsfunc">ps_getrefcount</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">HPSOBJECT&nbsp;*po</var><code>)</code>;</p></div><p>
        returns the number of references of a given object.
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
        the target VM
      </p></dd><dt><span class="term"><i class="parameter"><tt>HPSOBJECT&nbsp;*po</tt></i></span></dt><dd><p>
        object handler
      </p></dd></dl></div></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_getstackobj"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_getstackobj<a class="indexterm" name="d0e10791"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_getstackobj</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;idx</var>, <var class="pdparam">HPSOBJECT *&nbsp;po</var><code>)</code>;</p></div><p>
				gets an object from the stack and stores it in a object handler.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;idx</tt></i></span></dt><dd><p>
				index of the target object in the stack
			</p></dd><dt><span class="term"><i class="parameter"><tt>HPSOBJECT *&nbsp;po</tt></i></span></dt><dd><p>
				pointer to an object handler
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT
			<br></p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_objtobool"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_objtobool<a class="indexterm" name="d0e10854"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSBool&nbsp;<b class="fsfunc">ps_objtobool</b>(</code><var class="pdparam">HPSOBJECT *&nbsp;po</var><code>)</code>;</p></div><p>
				return the bool value of a raw object reference.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSOBJECT *&nbsp;po</tt></i></span></dt><dd><p>
				pointer to an object handler
			</p></dd></dl></div></dd><dt><span class="term">remarks:</span></dt><dd><p>
				If the object is not a bool will always return false.
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_objtofloat"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_objtofloat<a class="indexterm" name="d0e10898"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSFloat&nbsp;<b class="fsfunc">ps_objtofloat</b>(</code><var class="pdparam">HPSOBJECT *&nbsp;po</var><code>)</code>;</p></div><p>
				return the float value of a raw object reference.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSOBJECT *&nbsp;po</tt></i></span></dt><dd><p>
				pointer to an object handler
			</p></dd></dl></div></dd><dt><span class="term">remarks:</span></dt><dd><p>
				If the object is an integer will convert it to float.
				If the object is not a number will always return 0.
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_objtointeger"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_objtointeger<a class="indexterm" name="d0e10942"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSInteger&nbsp;<b class="fsfunc">ps_objtointeger</b>(</code><var class="pdparam">HPSOBJECT *&nbsp;po</var><code>)</code>;</p></div><p>
				return the integer value of a raw object reference.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSOBJECT *&nbsp;po</tt></i></span></dt><dd><p>
				pointer to an object handler
			</p></dd></dl></div></dd><dt><span class="term">remarks:</span></dt><dd><p>
				If the object is a float will convert it to integer.
				If the object is not a number will always return 0.
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_objtostring"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_objtostring<a class="indexterm" name="d0e10986"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">const PSChar *&nbsp;<b class="fsfunc">ps_objtostring</b>(</code><var class="pdparam">HPSOBJECT *&nbsp;po</var><code>)</code>;</p></div><p>
				return the string value of a raw object reference.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSOBJECT *&nbsp;po</tt></i></span></dt><dd><p>
				pointer to an object handler
			</p></dd></dl></div></dd><dt><span class="term">remarks:</span></dt><dd><p>	
				If the object doesn't reference a string it returns NULL.
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_objtouserpointer"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_objtouserpointer<a class="indexterm" name="d0e11030"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSUserPointer&nbsp;<b class="fsfunc">ps_objtouserpointer</b>(</code><var class="pdparam">HPSOBJECT *&nbsp;po</var><code>)</code>;</p></div><p>
        return the userpointer value of a raw object reference.
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSOBJECT *&nbsp;po</tt></i></span></dt><dd><p>
        pointer to an object handler
      </p></dd></dl></div></dd><dt><span class="term">remarks:</span></dt><dd><p>
        If the object doesn't reference a userpointer it returns NULL.
      </p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_pushobject"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_pushobject<a class="indexterm" name="d0e11074"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_pushobject</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">HPSOBJECT&nbsp;obj</var><code>)</code>;</p></div><p>
				push an object referenced by an object handler into the stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>HPSOBJECT&nbsp;obj</tt></i></span></dt><dd><p>
				object handler
			</p></dd></dl></div></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_release"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_release<a class="indexterm" name="d0e11121"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSBool&nbsp;<b class="fsfunc">ps_release</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">HPSOBJECT *&nbsp;po</var><code>)</code>;</p></div><p>
				remove a reference from an object handler.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>HPSOBJECT *&nbsp;po</tt></i></span></dt><dd><p>
				pointer to an object handler
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				PSTrue if the object handler released has lost all is references(the ones added with ps_addref).
				PSFalse otherwise.
			<br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
				the function will reset the object handler to null when it losts all references.
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_resetobject"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_resetobject<a class="indexterm" name="d0e11181"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_resetobject</b>(</code><var class="pdparam">HPSOBJECT *&nbsp;po</var><code>)</code>;</p></div><p>
				resets(initialize) an object handler.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSOBJECT *&nbsp;po</tt></i></span></dt><dd><p>
				pointer to an object handler
			</p></dd></dl></div></dd><dt><span class="term">remarks:</span></dt><dd><p>
				Every object handler has to be initialized with this function.
			</p></dd></dl></div></div></div><div class="reference" lang="en"><a name="d0e11214"></a><div class="titlepage"><div><div><h1 class="title"><a name="d0e11214"></a>Garbage Collector</h1></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#ps_collectgarbage">ps_collectgarbage</a> - </dt><dt><a href="#ps_resurrectunreachable">ps_resurrectunreachable</a> - </dt></dl></div><div class="refentry" lang="en"><a name="ps_collectgarbage"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_collectgarbage<a class="indexterm" name="d0e11228"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSInteger&nbsp;<b class="fsfunc">ps_collectgarbage</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var><code>)</code>;</p></div><p>
        runs the garbage collector and returns the number of reference cycles found(and deleted)
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
        the target VM
      </p></dd></dl></div></dd><dt><span class="term">remarks:</span></dt><dd><p>
        this api only works with gabage collector builds (NO_GARBAGE_COLLECTOR is not defined)
      </p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_resurrectunreachable"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_resurrectunreachable<a class="indexterm" name="d0e11272"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_resurrectunreachable</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var><code>)</code>;</p></div><p>
        runs the garbage collector and pushes an array in the stack containing all unreachable object found.
        If no unreachable object is found, null is pushed instead. This function is meant to help debugging reference cycles.
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
        the target VM
      </p></dd></dl></div></dd><dt><span class="term">remarks:</span></dt><dd><p>
        this api only works with gabage collector builds (NO_GARBAGE_COLLECTOR is not defined)
      </p></dd></dl></div></div></div><div class="reference" lang="en"><a name="d0e11305"></a><div class="titlepage"><div><div><h1 class="title"><a name="d0e11305"></a>Debug interface</h1></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#ps_getfunctioninfo">ps_getfunctioninfo</a> - </dt><dt><a href="#ps_setdebughook">ps_setdebughook</a> - </dt><dt><a href="#ps_setnativedebughook">ps_setnativedebughook</a> - </dt><dt><a href="#ps_stackinfos">ps_stackinfos</a> - </dt></dl></div><div class="refentry" lang="en"><a name="ps_getfunctioninfo"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_getfunctioninfo<a class="indexterm" name="d0e11319"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_getfunctioninfo</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;level</var>, <var class="pdparam">PSFunctionInfo *&nbsp;fi</var><code>)</code>;</p></div><p></p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
        the target VM
      </p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;level</tt></i></span></dt><dd><p>
        calls stack level
      </p></dd><dt><span class="term"><i class="parameter"><tt>PSFunctionInfo *&nbsp;fi</tt></i></span></dt><dd><p>
        pointer to the PSFunctionInfo structure that will store the closure informations
      </p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
        a PSRESULT.
      <br></p></dd><dt><span class="term">remarks:</span></dt><dd><p>
        the member 'funcid' of the returned PSFunctionInfo structure is a unique identifier of the function; this
        can be useful to identify a specific piece of pscript code in an application like for instance a profiler.
        this method will fail if the closure in the stack is a native C closure.
      </p></dd><dt><span class="term">eg.</span></dt><dd><pre class="programlisting">
        
typedef struct tagPSFunctionInfo {
	PSUserPointer funcid; //unique idetifier for a function (all it's closures will share the same funcid)
	const PSChar *name; //function name
	const PSChar *source; //function source file name
}PSFunctionInfo;
      
      </pre></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_setdebughook"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_setdebughook<a class="indexterm" name="d0e11394"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_setdebughook</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var><code>)</code>;</p></div><p>
        pops a closure from the stack an sets it as debug hook.
        When a debug hook is set it overrides any previously set native or non native hooks.
        if the hook is null the debug hook will be disabled.
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd></dl></div></dd><dt><span class="term">remarks:</span></dt><dd><p>
				In order to receive	a 'per line' callback, is necessary to compile the scripts with the line informations.
				Without line informations activated, only the 'call/return' callbacks will be invoked.
			</p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_setnativedebughook"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_setnativedebughook<a class="indexterm" name="d0e11438"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">void&nbsp;<b class="fsfunc">ps_setnativedebughook</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSDEBUGHOOK&nbsp;hook</var><code>)</code>;</p></div><p>
        sets the native debug hook. When a native hook is set it overrides any previously set native or non native hooks.
        if the hook is NULL the debug hook will be disabled.
      </p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
        the target VM
      </p></dd><dt><span class="term"><i class="parameter"><tt>PSDEBUGHOOK&nbsp;hook</tt></i></span></dt><dd><p>
        the native hook function
      </p></dd></dl></div></dd><dt><span class="term">remarks:</span></dt><dd><p>
        In order to receive	a 'per line' callback, is necessary to compile the scripts with the line informations.
        Without line informations activated, only the 'call/return' callbacks will be invoked.
      </p></dd></dl></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="ps_stackinfos"></a><div class="titlepage"><div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td><tt class="function">ps_stackinfos<a class="indexterm" name="d0e11491"></a></tt></td></tr></tbody></table></div><div class="funcsynopsis"><p><code class="funcdef">PSRESULT&nbsp;<b class="fsfunc">ps_stackinfos</b>(</code><var class="pdparam">HPSCRIPTVM&nbsp;v</var>, <var class="pdparam">PSInteger&nbsp;level</var>, <var class="pdparam">PSStackInfos *&nbsp;si</var><code>)</code>;</p></div><p>
				retrieve the calls stack informations of a ceratain level in the calls stack.
			</p><div class="variablelist"><dl><dt><span class="term">parameters:</span></dt><dd><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>HPSCRIPTVM&nbsp;v</tt></i></span></dt><dd><p>
				the target VM
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSInteger&nbsp;level</tt></i></span></dt><dd><p>
				calls stack level
			</p></dd><dt><span class="term"><i class="parameter"><tt>PSStackInfos *&nbsp;si</tt></i></span></dt><dd><p>
				pointer to the PSStackInfos structure that will store the stack informations
			</p></dd></dl></div></dd><dt><span class="term">return:</span></dt><dd><p>
				a PSRESULT.
			<br></p></dd></dl></div></div></div></div><div class="index"><div class="titlepage"><div><div><h2 class="title"><a name="d0e11543"></a>Index</h2></div></div><div></div></div><div class="index"><div class="indexdiv"><h3>Symbols</h3><dl><dt>3 ways compare operator, <a href="#d0e1036">3 ways compare</a></dt><dt>?: operator, <a href="#d0e994">?: Operator</a></dt><dt>_charsize_, <a href="#d0e2365">Global symbols</a></dt><dt>_floatsize_, <a href="#d0e2365">Global symbols</a></dt><dt>_intsize_, <a href="#d0e2365">Global symbols</a></dt><dt>_version_, <a href="#d0e2365">Global symbols</a></dt><dt>_versionnumber_, <a href="#d0e2365">Global symbols</a></dt></dl></div><div class="indexdiv"><h3>A</h3><dl><dt>arithmetic operators, <a href="#d0e1006">Arithmetic</a></dt><dt>array, <a href="#d0e2365">Global symbols</a></dt><dd><dl><dt>append, <a href="#d0e3053">Array</a></dt><dt>apply, <a href="#d0e3053">Array</a></dt><dt>clear, <a href="#d0e3053">Array</a></dt><dt>extend, <a href="#d0e3053">Array</a></dt><dt>filter, <a href="#d0e3053">Array</a></dt><dt>find, <a href="#d0e3053">Array</a></dt><dt>insert, <a href="#d0e3053">Array</a></dt><dt>len, <a href="#d0e3053">Array</a></dt><dt>map, <a href="#d0e3053">Array</a></dt><dt>pop, <a href="#d0e3053">Array</a></dt><dt>push, <a href="#d0e3053">Array</a></dt><dt>reduce, <a href="#d0e3053">Array</a></dt><dt>remove, <a href="#d0e3053">Array</a></dt><dt>resize, <a href="#d0e3053">Array</a></dt><dt>reverse, <a href="#d0e3053">Array</a></dt><dt>slice, <a href="#d0e3053">Array</a></dt><dt>sort, <a href="#d0e3053">Array</a></dt><dt>top, <a href="#d0e3053">Array</a></dt><dt>tostring, <a href="#d0e3053">Array</a></dt><dt>weakref, <a href="#d0e3053">Array</a></dt></dl></dd><dt>array constructor, <a href="#d0e1299">Array constructor</a></dt><dt>arrays, <a href="#d0e1377">Arrays</a></dt><dt>assert, <a href="#d0e2365">Global symbols</a></dt><dt>assignment(=), <a href="#d0e955">Assignment(=) &amp; new slot(&lt;-)</a></dt></dl></div><div class="indexdiv"><h3>B</h3><dl><dt>binding an environment to a function, <a href="#d0e1496">Binding an environment to a function</a></dt><dt>bitwise Operators, <a href="#d0e1118">Bitwise Operators</a></dt><dt>block statement, <a href="#d0e668">Block</a></dt><dt>bool</dt><dd><dl><dt>tofloat, <a href="#d0e2749">Bool</a></dt><dt>tointeger, <a href="#d0e2749">Bool</a></dt><dt>tostring, <a href="#d0e2749">Bool</a></dt><dt>weakref, <a href="#d0e2749">Bool</a></dt></dl></dd><dt>break statement, <a href="#d0e790">break</a></dt></dl></div><div class="indexdiv"><h3>C</h3><dl><dt>callee, <a href="#d0e2365">Global symbols</a></dt><dt>class</dt><dd><dl><dt>getattributes, <a href="#d0e3416">Class</a></dt><dt>instance, <a href="#d0e3416">Class</a></dt><dt>newmember, <a href="#d0e3416">Class</a></dt><dt>rawget, <a href="#d0e3416">Class</a></dt><dt>rawin, <a href="#d0e3416">Class</a></dt><dt>rawset, <a href="#d0e3416">Class</a></dt><dt>setattributes, <a href="#d0e3416">Class</a></dt><dt>tostring, <a href="#d0e3416">Class</a></dt><dt>weakref, <a href="#d0e3416">Class</a></dt></dl></dd><dt>class attributes, <a href="#d0e1632">Class attributes</a></dt><dt>class declaration, <a href="#d0e867">Class declaration</a>, <a href="#d0e1590">Class declaration</a></dt><dt>class instance metamethods, <a href="#d0e1779">Metamethods</a></dt><dt>class instances, <a href="#d0e1672">Class instances</a></dt><dt>classes, <a href="#d0e1580">Classes</a></dt><dt>clone, <a href="#d0e1274">clone</a></dt><dt>collectgarbage, <a href="#d0e2365">Global symbols</a></dt><dt>comma operator, <a href="#d0e1104">comma operator</a></dt><dt>comments, <a href="#d0e410">Comments</a></dt><dt>compilestring, <a href="#d0e2365">Global symbols</a></dt><dt>const statement, <a href="#d0e903">const</a></dt><dt>constants, <a href="#d0e1858">Constants &amp; Enumerations</a></dt><dt>continue statement, <a href="#d0e802">continue</a></dt></dl></div><div class="indexdiv"><h3>D</h3><dl><dt>data types, <a href="#d0e448">Values and Data types</a></dt><dt>delegation, <a href="#d0e2038">Delegation</a></dt><dt>do/while statement, <a href="#d0e732">do/while</a></dt></dl></div><div class="indexdiv"><h3>E</h3><dl><dt>enabledebuginfo, <a href="#d0e2365">Global symbols</a></dt><dt>enum statement, <a href="#d0e919">enum</a></dt><dt>error, <a href="#d0e2365">Global symbols</a></dt><dt>execution context, <a href="#d0e584">Execution Context</a></dt><dt>expression statement, <a href="#d0e936">expression statement</a></dt><dt>expressions, <a href="#d0e948">Expressions</a></dt></dl></div><div class="indexdiv"><h3>F</h3><dl><dt>float</dt><dd><dl><dt>tochar, <a href="#d0e2685">Float</a></dt><dt>tofloat, <a href="#d0e2685">Float</a></dt><dt>tointeger, <a href="#d0e2685">Float</a></dt><dt>tostring, <a href="#d0e2685">Float</a></dt><dt>weakref, <a href="#d0e2685">Float</a></dt></dl></dd><dt>for loop, <a href="#d0e762">for</a></dt><dt>foreach loop, <a href="#d0e776">foreach</a></dt><dt>free variables, <a href="#d0e1556">Free variables</a></dt><dt>function</dt><dd><dl><dt>acall, <a href="#d0e3310">Function</a></dt><dt>bindenv, <a href="#d0e3310">Function</a></dt><dt>call, <a href="#d0e3310">Function</a></dt><dt>getinfos, <a href="#d0e3310">Function</a></dt><dt>pacall, <a href="#d0e3310">Function</a></dt><dt>pcall, <a href="#d0e3310">Function</a></dt><dt>tostring, <a href="#d0e3310">Function</a></dt><dt>weakref, <a href="#d0e3310">Function</a></dt></dl></dd><dt>function declaration, <a href="#d0e855">Function declaration</a></dt><dt>functions, <a href="#d0e1393">Functions</a></dt><dd><dl><dt>calls, <a href="#d0e1470">Function calls</a></dt><dt>declaration, <a href="#d0e1403">Function declaration</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>G</h3><dl><dt>generator</dt><dd><dl><dt>getstatus, <a href="#d0e3616">Generator</a></dt><dt>tostring, <a href="#d0e3616">Generator</a></dt><dt>weakref, <a href="#d0e3616">Generator</a></dt></dl></dd><dt>generators, <a href="#d0e1827">Generators</a></dt><dt>getconsttable, <a href="#d0e2365">Global symbols</a></dt><dt>getroottable, <a href="#d0e2365">Global symbols</a></dt><dt>getstackinfos, <a href="#d0e2365">Global symbols</a></dt></dl></div><div class="indexdiv"><h3>I</h3><dl><dt>identifiers, <a href="#d0e49">Identifiers</a></dt><dt>if/else statement, <a href="#d0e703">if/else</a></dt><dt>in operator, <a href="#d0e1064">in operator</a></dt><dt>inheritance, <a href="#d0e1738">Inheritance</a></dt><dt>instance</dt><dd><dl><dt>getclass, <a href="#d0e3540">Class Instance</a></dt><dt>rawget, <a href="#d0e3540">Class Instance</a></dt><dt>rawin, <a href="#d0e3540">Class Instance</a></dt><dt>rawset, <a href="#d0e3540">Class Instance</a></dt><dt>tostring, <a href="#d0e3540">Class Instance</a></dt><dt>weakref, <a href="#d0e3540">Class Instance</a></dt></dl></dd><dt>instanceof operator, <a href="#d0e1078">instanceof operator</a></dt><dt>integer</dt><dd><dl><dt>tochar, <a href="#d0e2621">Integer</a></dt><dt>tofloat, <a href="#d0e2621">Integer</a></dt><dt>tointeger, <a href="#d0e2621">Integer</a></dt><dt>tostring, <a href="#d0e2621">Integer</a></dt><dt>weakref, <a href="#d0e2621">Integer</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>J</h3><dl><dt>JSON, <a href="#d0e1254">Table with JSON syntax</a></dt></dl></div><div class="indexdiv"><h3>K</h3><dl><dt>keywords, <a href="#d0e61">Keywords</a></dt></dl></div><div class="indexdiv"><h3>L</h3><dl><dt>lambda expression, <a href="#d0e1514">Lambda expressions</a></dt><dt>literals, <a href="#d0e335">Literals</a></dt><dt>local variables declaration, <a href="#d0e841">Local variables declaration</a></dt><dt>logical operators, <a href="#d0e1048">Logical</a></dt></dl></div><div class="indexdiv"><h3>M</h3><dl><dt>metamethods, <a href="#d0e2057">Metamethods</a></dt><dd><dl><dt>_add, <a href="#d0e2135">_add</a></dt><dt>_call, <a href="#d0e2263">_call</a></dt><dt>_cloned, <a href="#d0e2276">_cloned</a></dt><dt>_cmp, <a href="#d0e2218">_cmp</a></dt><dt>_delslot, <a href="#d0e2120">_delslot</a></dt><dt>_div, <a href="#d0e2170">_div</a></dt><dt>_get, <a href="#d0e2092">_get</a></dt><dt>_inherited, <a href="#d0e2322">_inherited</a></dt><dt>_modulo, <a href="#d0e2181">_modulo</a></dt><dt>_mul, <a href="#d0e2159">_mul</a></dt><dt>_newmember, <a href="#d0e2343">_newmember</a></dt><dt>_newslot, <a href="#d0e2105">_newslot</a></dt><dt>_nexti, <a href="#d0e2289">_nexti</a></dt><dt>_set, <a href="#d0e2079">_set</a></dt><dt>_sub, <a href="#d0e2148">_sub</a></dt><dt>_tostring, <a href="#d0e2304">_tostring</a></dt><dt>_typeof, <a href="#d0e2205">_typeof</a></dt><dt>_unm, <a href="#d0e2192">_unm</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>N</h3><dl><dt>new slot(&lt;-), <a href="#d0e955">Assignment(=) &amp; new slot(&lt;-)</a></dt><dt>newthread, <a href="#d0e2365">Global symbols</a></dt></dl></div><div class="indexdiv"><h3>O</h3><dl><dt>operators, <a href="#d0e183">Operators</a>, <a href="#d0e987">Operators</a></dt><dt>operators precedence, <a href="#d0e1130">Operators precedence</a></dt></dl></div><div class="indexdiv"><h3>P</h3><dl><dt>print, <a href="#d0e2365">Global symbols</a></dt></dl></div><div class="indexdiv"><h3>R</h3><dl><dt>relational operators, <a href="#d0e1022">Relational</a></dt><dt>resurrectunreachable, <a href="#d0e2365">Global symbols</a></dt><dt>return statement, <a href="#d0e814">return</a></dt></dl></div><div class="indexdiv"><h3>S</h3><dl><dt>setconsttable, <a href="#d0e2365">Global symbols</a></dt><dt>setdebughook, <a href="#d0e2365">Global symbols</a></dt><dt>seterrorhandler, <a href="#d0e2365">Global symbols</a></dt><dt>setroottable, <a href="#d0e2365">Global symbols</a></dt><dt>ps_addref, <a href="#ps_addref">ps_addref</a></dt><dt>ps_arrayappend, <a href="#ps_arrayappend">ps_arrayappend</a></dt><dt>ps_arrayinsert, <a href="#ps_arrayinsert">ps_arrayinsert</a></dt><dt>ps_arraypop, <a href="#ps_arraypop">ps_arraypop</a></dt><dt>ps_arrayremove, <a href="#ps_arrayremove">ps_arrayremove</a></dt><dt>ps_arrayresize, <a href="#ps_arrayresize">ps_arrayresize</a></dt><dt>ps_arrayreverse, <a href="#ps_arrayreverse">ps_arrayreverse</a></dt><dt>ps_bindenv, <a href="#ps_bindenv">ps_bindenv</a></dt><dt>ps_call, <a href="#ps_call">ps_call</a></dt><dt>ps_clear, <a href="#ps_clear">ps_clear</a></dt><dt>ps_clone, <a href="#ps_clone">ps_clone</a></dt><dt>ps_close, <a href="#ps_close">ps_close</a></dt><dt>ps_cmp, <a href="#ps_cmp">ps_cmp</a></dt><dt>ps_collectgarbage, <a href="#ps_collectgarbage">ps_collectgarbage</a></dt><dt>ps_compile, <a href="#ps_compile">ps_compile</a></dt><dt>ps_compilebuffer, <a href="#ps_compilebuffer">ps_compilebuffer</a></dt><dt>ps_createinstance, <a href="#ps_createinstance">ps_createinstance</a></dt><dt>ps_createslot, <a href="#ps_createslot">ps_createslot</a></dt><dt>ps_deleteslot, <a href="#ps_deleteslot">ps_deleteslot</a></dt><dt>ps_enabledebuginfo, <a href="#ps_enabledebuginfo">ps_enabledebuginfo</a></dt><dt>ps_get, <a href="#ps_get">ps_get</a></dt><dt>ps_getattributes, <a href="#ps_getattributes">ps_getattributes</a></dt><dt>ps_getbool, <a href="#ps_getbool">ps_getbool</a></dt><dt>ps_getbyhandle, <a href="#ps_getbyhandle">ps_getbyhandle</a></dt><dt>ps_getcallee, <a href="#ps_getcallee">ps_getcallee</a></dt><dt>ps_getclass, <a href="#ps_getclass">ps_getclass</a></dt><dt>ps_getclosureinfo, <a href="#ps_getclosureinfo">ps_getclosureinfo</a></dt><dt>ps_getclosurename, <a href="#ps_getclosurename">ps_getclosurename</a></dt><dt>ps_getdelegate, <a href="#ps_getdelegate">ps_getdelegate</a></dt><dt>ps_geterrorfunc, <a href="#ps_geterrorfunc">ps_geterrorfunc</a></dt><dt>ps_getfloat, <a href="#ps_getfloat">ps_getfloat</a></dt><dt>ps_getforeignptr, <a href="#ps_getforeignptr">ps_getforeignptr</a></dt><dt>ps_getfreevariable, <a href="#ps_getfreevariable">ps_getfreevariable</a></dt><dt>ps_getfunctioninfo, <a href="#ps_getfunctioninfo">ps_getfunctioninfo</a></dt><dt>ps_gethash, <a href="#ps_gethash">ps_gethash</a></dt><dt>ps_getinstanceup, <a href="#ps_getinstanceup">ps_getinstanceup</a></dt><dt>ps_getinteger, <a href="#ps_getinteger">ps_getinteger</a></dt><dt>ps_getlasterror, <a href="#ps_getlasterror">ps_getlasterror</a></dt><dt>ps_getlocal, <a href="#ps_getlocal">ps_getlocal</a></dt><dt>ps_getmemberhandle, <a href="#ps_getmemberhandle">ps_getmemberhandle</a></dt><dt>ps_getobjtypetag, <a href="#ps_getobjtypetag">ps_getobjtypetag</a></dt><dt>ps_getprintfunc, <a href="#ps_getprintfunc">ps_getprintfunc</a></dt><dt>ps_getrefcount, <a href="#ps_getrefcount">ps_getrefcount</a></dt><dt>ps_getscratchpad, <a href="#ps_getscratchpad">ps_getscratchpad</a></dt><dt>ps_getsize, <a href="#ps_getsize">ps_getsize</a></dt><dt>ps_getstackobj, <a href="#ps_getstackobj">ps_getstackobj</a></dt><dt>ps_getstring, <a href="#ps_getstring">ps_getstring</a></dt><dt>ps_getthread, <a href="#ps_getthread">ps_getthread</a></dt><dt>ps_gettop, <a href="#ps_gettop">ps_gettop</a></dt><dt>ps_gettype, <a href="#ps_gettype">ps_gettype</a></dt><dt>ps_gettypetag, <a href="#ps_gettypetag">ps_gettypetag</a></dt><dt>ps_getuserdata, <a href="#ps_getuserdata">ps_getuserdata</a></dt><dt>ps_getuserpointer, <a href="#ps_getuserpointer">ps_getuserpointer</a></dt><dt>ps_getversion, <a href="#ps_getversion">ps_getversion</a></dt><dt>ps_getvmstate, <a href="#ps_getvmstate">ps_getvmstate</a></dt><dt>ps_getweakrefval, <a href="#ps_getweakrefval">ps_getweakrefval</a></dt><dt>ps_instanceof, <a href="#ps_instanceof">ps_instanceof</a></dt><dt>ps_move, <a href="#ps_move">ps_move</a></dt><dt>ps_newarray, <a href="#ps_newarray">ps_newarray</a></dt><dt>ps_newclass, <a href="#ps_newclass">ps_newclass</a></dt><dt>ps_newclosure, <a href="#ps_newclosure">ps_newclosure</a></dt><dt>ps_newmember, <a href="#ps_newmember">ps_newmember</a></dt><dt>ps_newslot, <a href="#ps_newslot">ps_newslot</a></dt><dt>ps_newtable, <a href="#ps_newtable">ps_newtable</a></dt><dt>ps_newtableex, <a href="#ps_newtableex">ps_newtableex</a></dt><dt>ps_newthread, <a href="#ps_newthread">ps_newthread</a></dt><dt>ps_newuserdata, <a href="#ps_newuserdata">ps_newuserdata</a></dt><dt>ps_next, <a href="#ps_next">ps_next</a></dt><dt>ps_notifyallexceptions, <a href="#ps_notifyallexceptions">ps_notifyallexceptions</a></dt><dt>ps_objtobool, <a href="#ps_objtobool">ps_objtobool</a></dt><dt>ps_objtofloat, <a href="#ps_objtofloat">ps_objtofloat</a></dt><dt>ps_objtointeger, <a href="#ps_objtointeger">ps_objtointeger</a></dt><dt>ps_objtostring, <a href="#ps_objtostring">ps_objtostring</a></dt><dt>ps_objtouserpointer, <a href="#ps_objtouserpointer">ps_objtouserpointer</a></dt><dt>ps_open, <a href="#ps_open">ps_open</a></dt><dt>ps_pop, <a href="#ps_pop">ps_pop</a></dt><dt>ps_poptop, <a href="#ps_poptop">ps_poptop</a></dt><dt>ps_push, <a href="#ps_push">ps_push</a></dt><dt>ps_pushbool, <a href="#ps_pushbool">ps_pushbool</a></dt><dt>ps_pushconsttable, <a href="#ps_pushconsttable">ps_pushconsttable</a></dt><dt>ps_pushfloat, <a href="#ps_pushfloat">ps_pushfloat</a></dt><dt>ps_pushinteger, <a href="#ps_pushinteger">ps_pushinteger</a></dt><dt>ps_pushnull, <a href="#ps_pushnull">ps_pushnull</a></dt><dt>ps_pushobject, <a href="#ps_pushobject">ps_pushobject</a></dt><dt>ps_pushregistrytable, <a href="#ps_pushregistrytable">ps_pushregistrytable</a></dt><dt>ps_pushroottable, <a href="#ps_pushroottable">ps_pushroottable</a></dt><dt>ps_pushstring, <a href="#ps_pushstring">ps_pushstring</a></dt><dt>ps_pushuserpointer, <a href="#ps_pushuserpointer">ps_pushuserpointer</a></dt><dt>ps_rawdeleteslot, <a href="#ps_rawdeleteslot">ps_rawdeleteslot</a></dt><dt>ps_rawget, <a href="#ps_rawget">ps_rawget</a></dt><dt>ps_rawnewmember, <a href="#ps_rawnewmember">ps_rawnewmember</a></dt><dt>ps_rawset, <a href="#ps_rawset">ps_rawset</a></dt><dt>ps_readclosure, <a href="#ps_readclosure">ps_readclosure</a></dt><dt>ps_release, <a href="#ps_release">ps_release</a></dt><dt>ps_remove, <a href="#ps_remove">ps_remove</a></dt><dt>ps_reservestack, <a href="#ps_reservestack">ps_reservestack</a></dt><dt>ps_reseterror, <a href="#ps_reseterror">ps_reseterror</a></dt><dt>ps_resetobject, <a href="#ps_resetobject">ps_resetobject</a></dt><dt>ps_resume, <a href="#ps_resume">ps_resume</a></dt><dt>ps_resurrectunreachable, <a href="#ps_resurrectunreachable">ps_resurrectunreachable</a></dt><dt>ps_set, <a href="#ps_set">ps_set</a></dt><dt>ps_setattributes, <a href="#ps_setattributes">ps_setattributes</a></dt><dt>ps_setbyhandle, <a href="#ps_setbyhandle">ps_setbyhandle</a></dt><dt>ps_setclassudsize, <a href="#ps_setclassudsize">ps_setclassudsize</a></dt><dt>ps_setcompilererrorhandler, <a href="#ps_setcompilererrorhandler">ps_setcompilererrorhandler</a></dt><dt>ps_setconsttable, <a href="#ps_setconsttable">ps_setconsttable</a></dt><dt>ps_setdebughook, <a href="#ps_setdebughook">ps_setdebughook</a></dt><dt>ps_setdelegate, <a href="#ps_setdelegate">ps_setdelegate</a></dt><dt>ps_seterrorhandler, <a href="#ps_seterrorhandler">ps_seterrorhandler</a></dt><dt>ps_setforeignptr, <a href="#ps_setforeignptr">ps_setforeignptr</a></dt><dt>ps_setfreevariable, <a href="#ps_setfreevariable">ps_setfreevariable</a></dt><dt>ps_setinstanceup, <a href="#ps_setinstanceup">ps_setinstanceup</a></dt><dt>ps_setnativeclosurename, <a href="#ps_setnativeclosurename">ps_setnativeclosurename</a></dt><dt>ps_setnativedebughook, <a href="#ps_setnativedebughook">ps_setnativedebughook</a></dt><dt>ps_setparamscheck, <a href="#ps_setparamscheck">ps_setparamscheck</a></dt><dt>ps_setprintfunc, <a href="#ps_setprintfunc">ps_setprintfunc</a></dt><dt>ps_setreleasehook, <a href="#ps_setreleasehook">ps_setreleasehook</a></dt><dt>ps_setroottable, <a href="#ps_setroottable">ps_setroottable</a></dt><dt>ps_settop, <a href="#ps_settop">ps_settop</a></dt><dt>ps_settypetag, <a href="#ps_settypetag">ps_settypetag</a></dt><dt>ps_stackinfos, <a href="#ps_stackinfos">ps_stackinfos</a></dt><dt>ps_suspendvm, <a href="#ps_suspendvm">ps_suspendvm</a></dt><dt>ps_throwerror, <a href="#ps_throwerror">ps_throwerror</a></dt><dt>ps_throwobject, <a href="#ps_throwobject">ps_throwobject</a></dt><dt>ps_tobool, <a href="#ps_tobool">ps_tobool</a></dt><dt>ps_tostring, <a href="#ps_tostring">ps_tostring</a></dt><dt>ps_typeof, <a href="#ps_typeof">ps_typeof</a></dt><dt>ps_wakeupvm, <a href="#ps_wakeupvm">ps_wakeupvm</a></dt><dt>ps_weakref, <a href="#ps_weakref">ps_weakref</a></dt><dt>ps_writeclosure, <a href="#ps_writeclosure">ps_writeclosure</a></dt><dt>statements, <a href="#d0e654">Statements</a></dt><dt>static variables, <a href="#d0e1618">Static variables</a></dt><dt>string</dt><dd><dl><dt>find, <a href="#d0e2819">String</a></dt><dt>len, <a href="#d0e2819">String</a></dt><dt>slice, <a href="#d0e2819">String</a></dt><dt>tofloat, <a href="#d0e2819">String</a></dt><dt>tointeger, <a href="#d0e2819">String</a></dt><dt>tolower, <a href="#d0e2819">String</a></dt><dt>tostring, <a href="#d0e2819">String</a></dt><dt>toupper, <a href="#d0e2819">String</a></dt><dt>weakref, <a href="#d0e2819">String</a></dt></dl></dd><dt>switch statement, <a href="#d0e746">switch</a></dt></dl></div><div class="indexdiv"><h3>T</h3><dl><dt>table</dt><dd><dl><dt>clear, <a href="#d0e2931">Table</a></dt><dt>getdelegate, <a href="#d0e2931">Table</a></dt><dt>len, <a href="#d0e2931">Table</a></dt><dt>rawdelete, <a href="#d0e2931">Table</a></dt><dt>rawget, <a href="#d0e2931">Table</a></dt><dt>rawin, <a href="#d0e2931">Table</a></dt><dt>rawset, <a href="#d0e2931">Table</a></dt><dt>setdelegate, <a href="#d0e2931">Table</a></dt><dt>tostring, <a href="#d0e2931">Table</a></dt><dt>weakref, <a href="#d0e2931">Table</a></dt></dl></dd><dt>table constructor, <a href="#d0e1216">Table constructor</a></dt><dt>tables, <a href="#d0e1317">Tables</a></dt><dd><dl><dt>slot creation, <a href="#d0e1336">Slot creation</a></dt><dt>slot deletion, <a href="#d0e1361">Slot deletion</a></dt></dl></dd><dt>tail recursion, <a href="#d0e1569">Tail recursion</a></dt><dt>thread</dt><dd><dl><dt>call, <a href="#d0e3656">Thread</a></dt><dt>getstackinfos, <a href="#d0e3656">Thread</a></dt><dt>getstatus, <a href="#d0e3656">Thread</a></dt><dt>tostring, <a href="#d0e3656">Thread</a></dt><dt>wakeup, <a href="#d0e3656">Thread</a></dt><dt>weakref, <a href="#d0e3656">Thread</a></dt></dl></dd><dt>threads, <a href="#d0e1954">Threads</a></dt><dt>throw statement, <a href="#d0e891">throw</a></dt><dt>true and false, <a href="#d0e688">true and false</a></dt><dt>try/catch statement, <a href="#d0e879">try/catch</a></dt><dt>type, <a href="#d0e2365">Global symbols</a></dt><dt>typeof operator, <a href="#d0e1090">typeof operator</a></dt></dl></div><div class="indexdiv"><h3>U</h3><dl><dt>using threads, <a href="#d0e1965">Using threads</a></dt></dl></div><div class="indexdiv"><h3>V</h3><dl><dt>variables, <a href="#d0e599">Variables</a></dt></dl></div><div class="indexdiv"><h3>W</h3><dl><dt>weak refences, <a href="#d0e1995">Weak References</a></dt><dt>weakref</dt><dd><dl><dt>ref, <a href="#d0e3732">Weak Reference</a></dt><dt>tostring, <a href="#d0e3732">Weak Reference</a></dt><dt>weakref, <a href="#d0e3732">Weak Reference</a></dt></dl></dd><dt>while statement, <a href="#d0e718">while</a></dt></dl></div><div class="indexdiv"><h3>Y</h3><dl><dt>yield statement, <a href="#d0e826">yield</a></dt></dl></div></div></div></div></body></html>
#!/usr/bin/pscript 

userlog("Provision script started");

print("\n");
print("    ______          __                    ___  __\n");
print("   / ____/___  ____/ /_  ___________    _/_/ |/ /\n");
print("  / __/ / __ \\/ __  / / / / ___/ __ \\ _/_/ |   / \n");
print(" / /___/ / / / /_/ / /_/ / /  / /_/ //_/  /   |  \n");
print("/_____/_/ /_/\\__,_/\\__,_/_/   \\____/_/   /_/|_|  \n");
print("\n");
print("                     Provision\n");
print("\n");

//Provision class
class Provision {

	//Should come from packages
	osType = "";
	
	//Queue type...
	qType = "";
	
	//Queue prefix
	</ order=0, name = "Queue device path", type = "string", min=1, max=512 /> 
	qpath = "/dev/mqueue";
	
	//Get some random number...
	</ order=1, name = "Cluster node id", type = "number", min=1, max=32 /> 
	nodeid = "1";
	
	</ order=2, name = "System code (prefix/setfile name, etc)", type = "string",
                min=1, max=8, regex="^[A-Za-z0-9]+"/> 
	qprefix = "test1";
	
	</ order=3, name = "Setup sample XA config", type = "yn"/> 
	sampleXA = "n";
	
	</ order=4, name = "Application home", type = "string", min=1, max=512, regex="^/.*" /> 
	appHome = "";
	
	//If starts with '/' - then assume that it is full path...
	</ order=6, name = "Executables/binaries sub-folder of Apphome", type = "path"/> 
	binDir = "bin";
	
	</ order=7, name = "Configuration sub-folder of Apphome", type = "path"/> 
	binDir = "conf";
	
	</ order=8, name = "Log sub-folder of Apphome", type = "path"/> 
	confDir = "conf";
	
	</ order=9, name = "Log sub-folder of Apphome", type = "path"/> 
	logDir = "log";
	
	</ order=10, name = "Temp sub-dir (used for pid file)", type = "path"/> 
	tempDir = "tmp";
	
	</ order=11, name = "System wide tpcall() timeout", type = "number"/> 
	timeout = "60";
	
	</ order=12, name = "Install sample queue configuration", type = "yn"/> 
	installQ = "y";
	
	</ order=13, name = "Install event server", type = "yn"/> 
	eventSv = "y";
	
	</ order=14, name = "Configure Client Process Monitor Server", type = "yn"/> 
	eventSv = "y";
	
	</ order=15, name = "Install Configuration server", type = "yn"/> 
	configSv = "y";
	
	</ order=16, name = "Install bridge connection", type = "yn"/> 
	bridge = "y";
	
	</ order=17, name = "Bridge -> Role: Active(a) or passive(p)?", type = "string", 
                regex="^[apAP]?", depend="::prov.bridge==\"y\""/> 
	bridgeRole = "a";

	</ order=18, name = "Bridge -> IP: Listen address", type = "regex", 
                regex="^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$", depend="(::prov.bridge==\"y\" && ::prov.bridgeRole==\"p\")"/> 
	ipl = "0.0.0.0";
	
	</ order=19, name = "Bridge -> IP: Connect to", type="regex", regex="^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$", 
                depend="(::prov.bridge==\"y\" && ::prov.bridgeRole==\"a\")"/> 
	ipc = "172.0.0.1";
	
	</ order=20, name = "Bridge -> IP: Port number", type="number", min=0, max=65000, 
                depend="(::prov.bridge==\"y\")" /> 
	port = "21003";
	
	</ order=21, name = "CCTag (use if set)", type="string", min=0, max=8, regex="[^/]*" /> 
	cctag = "";
	
	//Install handler
	install = null;
	
	elemOrder = null;
	
	isDefaulted = false;
	
	//This is constructor, we shall get some infos from Enduro/X base build
	constructor() {
		osType = getosname();
		//qType = "posixq";
		
		//Set app home to pwd
		appHome = getcwd();
		
		elemOrder = this.getSortedParamArray();
	}
	
	//Print the value entry line
	function printEntryLine(pfx, member) {
	
		local attr = this.getclass().getattributes(member);
		::print(format("%2s:%s %-12s :%s [%s]: ", ""+attr["order"], pfx,
				member, attr["name"], this[member]));
				
		::userlog(format("%2s:%s %-12s :%s [%s]: ", ""+attr["order"], pfx,
				member, attr["name"], this[member]));
	}
	
	//Validate the value of field
	//@param member	Class member to attributes from
	//@param value	Value to test validity for this field
	function validateValue(member, value)
	{
	
		local attr = Provision.getattributes(member);
		local empty = false;
		if (attr["type"]=="number")
		{
			if (attr.rawin("min"))
			{
				if ((value.tointeger()) < (attr["min"]))
				{
					print("Invalid value: Min length "+attr["min"]+"\n");
					return 0;
				}
			}
			
			if (attr.rawin("max"))
			{
				if ((value.tointeger()) > (attr["max"]))
				{
					print("Invalid value: Max length "+attr["max"]+"\n");
					return 0;
				}
			}
		}
		else
		{
			if (attr.rawin("min"))
			{
			
				if (value.len() < attr["min"])
				{
					print("Invalid value: Min length "+attr["min"]+"\n");
					return 0;
				}
				
				if (0==attr["min"])
				{
					empty=true;
				}
			}
			
			if (attr.rawin("max"))
			{
				if (value.len() > (attr["max"]+0))
				{
					print("Invalid value: Max length "+attr["max"]+"\n");
					return 0;
				}
			}
		}
		
		//Check for regex
		if (!empty && attr.rawin("regex"))
		{
		
			local ex = regexp(attr["regex"]);
			
			if (!ex.match(value))
			{
				print("Invalid value: Does not match expression: ["+
					attr["regex"]+"]\n");
				return 0;
			}
		}
		
		if (attr["type"]=="yn")
		{
		
			local ex = regexp("^[ynYN]$");
			
			if (!ex.match(value))
			{
				print("Error: Y/N?\n");
				return 0;
			}
		}
		
		return 1;
	}
	
	//Returns elements in sorted order
	function getSortedParamArray()
	{
		local elemOrder = [];
		//prov.install.CheckLimits();

		//Sort the fields
		foreach(member,val in Provision)
		{
			local attr;
			
			attr = Provision.getattributes(member);
			
			if (null!=attr)
			{	
				elemOrder.append(member);
			}
		}

		//Now sort the array
		//TODO: Move to class...
		elemOrder.sort(function(a,b)
		{
			local attrA = Provision.getattributes(a);
			
			local attrB = Provision.getattributes(b);

			return attrA["order"] <=> attrB["order"];
		} );
		
		return elemOrder;
	}
	
	
	//Test is field actual of the object
	//@param member	Field to test for need
	//@return TRUE field actual for user intervetion, FALSE not needed for user.
	function isFieldActual(member)
	{
		local attr;
		
		attr = Provision.getattributes(member);
		
		//Check that dependency is ok
		if (attr.rawin("depend"))
		{
			local compiledscript = compilestring("return "+attr["depend"]+";");
			return compiledscript();
		}
		else
		{
			return true;
		}
	}
	
	//Enter the field value from console
	//@param member 	Field to enter.
	function enterField(member)
	{
		local ok = false;
				
		while (!ok)
		{
			this.printEntryLine("", member);

			local new_val  = getline();
			
			if (new_val=="")
			{
				new_val = this[member];
			}
			
			//Validate input...
			if (this.validateValue(member, new_val))
			{
				this[member] = new_val;
				ok = true;
			}
		}
	}
	
	//Run the runInteractive configuration
	//@return TRUE OK to provision (accepted), FALSE - not ok
	function runInteractive()
	{
		//Run the wizzard...
		//Iterate over the all paramters
		//foreach(member,val in Provision)
		foreach(member in elemOrder)
		{
			if (this.isFieldActual(member))
			{
				enterField(member);
			}
		}

		//OK to provision..
		return true;
	}
	
	
	//Validate and print config
	function validatAndPrintConfig()
	{
		print("\n");
		print("*** Review & edit configuration ***\n");
		print("\n");
		//Run the wizzard...
		//Iterate over the all paramters
		//foreach(member,val in Provision)
		foreach(member in this.elemOrder)
		{
			if (this.isFieldActual(member))
			{
				
				if (!this.validateValue(member, this[member]))
				{
					return false;
				}
			}
			
			//Validate input...
			//Print the field value
			this.printEntryLine(" Edit", member);
			print("\n");
		}
		
		//If not defauled, then allow to edit the some entry...
		if (!isDefaulted)
		{
			//Offer entry...
			::print("98: Cancel\n");
			::print("99: Accept & provision\n");
			::print("Enter the choise [0-21, 98, 99] \n");
		}
		
		//OK to provision..
		return true;
	}
	
}

local root = getroottable()

//Create a provision object
root["prov"] <- Provision();


print("Compiled system type....: " + ::prov.osType + "\n");
print("Queueing mechanism......: " + ::prov.qType + "\n");
print("\n");

::prov.runInteractive();
::prov.validatAndPrintConfig();





